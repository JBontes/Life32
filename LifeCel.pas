{$A8,B-,C+,D+,E-,F-,G+,H+,I+,J+,K-,L+,M-,N+,O+,P+,Q-,R-,S-,T-,U-,V+,W-,X+,Y-,Z1}
{$MINSTACKSIZE $00004000}
{$MAXSTACKSIZE $00100000}
{$IMAGEBASE $00400000}
{$APPTYPE GUI}
{$WARN SYMBOL_DEPRECATED ON}
{$WARN SYMBOL_LIBRARY ON}
{$WARN SYMBOL_PLATFORM ON}
{$WARN SYMBOL_EXPERIMENTAL ON}
{$WARN UNIT_LIBRARY ON}
{$WARN UNIT_PLATFORM ON}
{$WARN UNIT_DEPRECATED ON}
{$WARN UNIT_EXPERIMENTAL ON}
{$WARN HRESULT_COMPAT ON}
{$WARN HIDING_MEMBER ON}
{$WARN HIDDEN_VIRTUAL ON}
{$WARN GARBAGE ON}
{$WARN BOUNDS_ERROR ON}
{$WARN ZERO_NIL_COMPAT ON}
{$WARN STRING_CONST_TRUNCED ON}
{$WARN FOR_LOOP_VAR_VARPAR ON}
{$WARN TYPED_CONST_VARPAR ON}
{$WARN ASG_TO_TYPED_CONST ON}
{$WARN CASE_LABEL_RANGE ON}
{$WARN FOR_VARIABLE ON}
{$WARN CONSTRUCTING_ABSTRACT ON}
{$WARN COMPARISON_FALSE ON}
{$WARN COMPARISON_TRUE ON}
{$WARN COMPARING_SIGNED_UNSIGNED ON}
{$WARN COMBINING_SIGNED_UNSIGNED ON}
{$WARN UNSUPPORTED_CONSTRUCT ON}
{$WARN FILE_OPEN ON}
{$WARN FILE_OPEN_UNITSRC ON}
{$WARN BAD_GLOBAL_SYMBOL ON}
{$WARN DUPLICATE_CTOR_DTOR ON}
{$WARN INVALID_DIRECTIVE ON}
{$WARN PACKAGE_NO_LINK ON}
{$WARN PACKAGED_THREADVAR ON}
{$WARN IMPLICIT_IMPORT ON}
{$WARN HPPEMIT_IGNORED ON}
{$WARN NO_RETVAL ON}
{$WARN USE_BEFORE_DEF ON}
{$WARN FOR_LOOP_VAR_UNDEF ON}
{$WARN UNIT_NAME_MISMATCH ON}
{$WARN NO_CFG_FILE_FOUND ON}
{$WARN IMPLICIT_VARIANTS ON}
{$WARN UNICODE_TO_LOCALE ON}
{$WARN LOCALE_TO_UNICODE ON}
{$WARN IMAGEBASE_MULTIPLE ON}
{$WARN SUSPICIOUS_TYPECAST ON}
{$WARN PRIVATE_PROPACCESSOR ON}
{$WARN UNSAFE_TYPE OFF}
{$WARN UNSAFE_CODE OFF}
{$WARN UNSAFE_CAST OFF}
{$WARN OPTION_TRUNCATED ON}
{$WARN WIDECHAR_REDUCED ON}
{$WARN DUPLICATES_IGNORED ON}
{$WARN UNIT_INIT_SEQ ON}
{$WARN LOCAL_PINVOKE ON}
{$WARN MESSAGE_DIRECTIVE ON}
{$WARN TYPEINFO_IMPLICITLY_ADDED ON}
{$WARN RLINK_WARNING ON}
{$WARN IMPLICIT_STRING_CAST ON}
{$WARN IMPLICIT_STRING_CAST_LOSS ON}
{$WARN EXPLICIT_STRING_CAST OFF}
{$WARN EXPLICIT_STRING_CAST_LOSS OFF}
{$WARN CVT_WCHAR_TO_ACHAR ON}
{$WARN CVT_NARROWING_STRING_LOST ON}
{$WARN CVT_ACHAR_TO_WCHAR ON}
{$WARN CVT_WIDENING_STRING_LOST ON}
{$WARN NON_PORTABLE_TYPECAST ON}
{$WARN XML_WHITESPACE_NOT_ALLOWED ON}
{$WARN XML_UNKNOWN_ENTITY ON}
{$WARN XML_INVALID_NAME_START ON}
{$WARN XML_INVALID_NAME ON}
{$WARN XML_EXPECTED_CHARACTER ON}
{$WARN XML_CREF_NO_RESOLVE ON}
{$WARN XML_NO_PARM ON}
{$WARN XML_NO_MATCHING_PARM ON}
{$WARN IMMUTABLE_STRINGS OFF}
{$A8,B-,C+,D+,E-,F-,G+,H+,I+,J+,K-,L+,M-,N+,O+,P+,Q-,R-,S-,T-,U-,V+,W-,X+,Y-,Z1}
{$MINSTACKSIZE $00004000}
{$MAXSTACKSIZE $00100000}
{$IMAGEBASE $00400000}
{$APPTYPE GUI}
{$WARN SYMBOL_DEPRECATED ON}
{$WARN SYMBOL_LIBRARY ON}
{$WARN SYMBOL_PLATFORM ON}
{$WARN SYMBOL_EXPERIMENTAL ON}
{$WARN UNIT_LIBRARY ON}
{$WARN UNIT_PLATFORM ON}
{$WARN UNIT_DEPRECATED ON}
{$WARN UNIT_EXPERIMENTAL ON}
{$WARN HRESULT_COMPAT ON}
{$WARN HIDING_MEMBER ON}
{$WARN HIDDEN_VIRTUAL ON}
{$WARN GARBAGE ON}
{$WARN BOUNDS_ERROR ON}
{$WARN ZERO_NIL_COMPAT ON}
{$WARN STRING_CONST_TRUNCED ON}
{$WARN FOR_LOOP_VAR_VARPAR ON}
{$WARN TYPED_CONST_VARPAR ON}
{$WARN ASG_TO_TYPED_CONST ON}
{$WARN CASE_LABEL_RANGE ON}
{$WARN FOR_VARIABLE ON}
{$WARN CONSTRUCTING_ABSTRACT ON}
{$WARN COMPARISON_FALSE ON}
{$WARN COMPARISON_TRUE ON}
{$WARN COMPARING_SIGNED_UNSIGNED ON}
{$WARN COMBINING_SIGNED_UNSIGNED ON}
{$WARN UNSUPPORTED_CONSTRUCT ON}
{$WARN FILE_OPEN ON}
{$WARN FILE_OPEN_UNITSRC ON}
{$WARN BAD_GLOBAL_SYMBOL ON}
{$WARN DUPLICATE_CTOR_DTOR ON}
{$WARN INVALID_DIRECTIVE ON}
{$WARN PACKAGE_NO_LINK ON}
{$WARN PACKAGED_THREADVAR ON}
{$WARN IMPLICIT_IMPORT ON}
{$WARN HPPEMIT_IGNORED ON}
{$WARN NO_RETVAL ON}
{$WARN USE_BEFORE_DEF ON}
{$WARN FOR_LOOP_VAR_UNDEF ON}
{$WARN UNIT_NAME_MISMATCH ON}
{$WARN NO_CFG_FILE_FOUND ON}
{$WARN IMPLICIT_VARIANTS ON}
{$WARN UNICODE_TO_LOCALE ON}
{$WARN LOCALE_TO_UNICODE ON}
{$WARN IMAGEBASE_MULTIPLE ON}
{$WARN SUSPICIOUS_TYPECAST ON}
{$WARN PRIVATE_PROPACCESSOR ON}
{$WARN UNSAFE_TYPE OFF}
{$WARN UNSAFE_CODE OFF}
{$WARN UNSAFE_CAST OFF}
{$WARN OPTION_TRUNCATED ON}
{$WARN WIDECHAR_REDUCED ON}
{$WARN DUPLICATES_IGNORED ON}
{$WARN UNIT_INIT_SEQ ON}
{$WARN LOCAL_PINVOKE ON}
{$WARN MESSAGE_DIRECTIVE ON}
{$WARN TYPEINFO_IMPLICITLY_ADDED ON}
{$WARN RLINK_WARNING ON}
{$WARN IMPLICIT_STRING_CAST ON}
{$WARN IMPLICIT_STRING_CAST_LOSS ON}
{$WARN EXPLICIT_STRING_CAST OFF}
{$WARN EXPLICIT_STRING_CAST_LOSS OFF}
{$WARN CVT_WCHAR_TO_ACHAR ON}
{$WARN CVT_NARROWING_STRING_LOST ON}
{$WARN CVT_ACHAR_TO_WCHAR ON}
{$WARN CVT_WIDENING_STRING_LOST ON}
{$WARN NON_PORTABLE_TYPECAST ON}
{$WARN XML_WHITESPACE_NOT_ALLOWED ON}
{$WARN XML_UNKNOWN_ENTITY ON}
{$WARN XML_INVALID_NAME_START ON}
{$WARN XML_INVALID_NAME ON}
{$WARN XML_EXPECTED_CHARACTER ON}
{$WARN XML_CREF_NO_RESOLVE ON}
{$WARN XML_NO_PARM ON}
{$WARN XML_NO_MATCHING_PARM ON}
{$WARN IMMUTABLE_STRINGS OFF}
{$A8,B-,C+,D+,E-,F-,G+,H+,I+,J+,K-,L+,M-,N+,O+,P+,Q-,R-,S-,T-,U-,V+,W-,X+,Y-,Z1}
{$MINSTACKSIZE $00004000}
{$MAXSTACKSIZE $00100000}
{$IMAGEBASE $00400000}
{$APPTYPE GUI}
{$WARN SYMBOL_DEPRECATED ON}
{$WARN SYMBOL_LIBRARY ON}
{$WARN SYMBOL_PLATFORM ON}
{$WARN SYMBOL_EXPERIMENTAL ON}
{$WARN UNIT_LIBRARY ON}
{$WARN UNIT_PLATFORM ON}
{$WARN UNIT_DEPRECATED ON}
{$WARN UNIT_EXPERIMENTAL ON}
{$WARN HRESULT_COMPAT ON}
{$WARN HIDING_MEMBER ON}
{$WARN HIDDEN_VIRTUAL ON}
{$WARN GARBAGE ON}
{$WARN BOUNDS_ERROR ON}
{$WARN ZERO_NIL_COMPAT ON}
{$WARN STRING_CONST_TRUNCED ON}
{$WARN FOR_LOOP_VAR_VARPAR ON}
{$WARN TYPED_CONST_VARPAR ON}
{$WARN ASG_TO_TYPED_CONST ON}
{$WARN CASE_LABEL_RANGE ON}
{$WARN FOR_VARIABLE ON}
{$WARN CONSTRUCTING_ABSTRACT ON}
{$WARN COMPARISON_FALSE ON}
{$WARN COMPARISON_TRUE ON}
{$WARN COMPARING_SIGNED_UNSIGNED ON}
{$WARN COMBINING_SIGNED_UNSIGNED ON}
{$WARN UNSUPPORTED_CONSTRUCT ON}
{$WARN FILE_OPEN ON}
{$WARN FILE_OPEN_UNITSRC ON}
{$WARN BAD_GLOBAL_SYMBOL ON}
{$WARN DUPLICATE_CTOR_DTOR ON}
{$WARN INVALID_DIRECTIVE ON}
{$WARN PACKAGE_NO_LINK ON}
{$WARN PACKAGED_THREADVAR ON}
{$WARN IMPLICIT_IMPORT ON}
{$WARN HPPEMIT_IGNORED ON}
{$WARN NO_RETVAL ON}
{$WARN USE_BEFORE_DEF ON}
{$WARN FOR_LOOP_VAR_UNDEF ON}
{$WARN UNIT_NAME_MISMATCH ON}
{$WARN NO_CFG_FILE_FOUND ON}
{$WARN IMPLICIT_VARIANTS ON}
{$WARN UNICODE_TO_LOCALE ON}
{$WARN LOCALE_TO_UNICODE ON}
{$WARN IMAGEBASE_MULTIPLE ON}
{$WARN SUSPICIOUS_TYPECAST ON}
{$WARN PRIVATE_PROPACCESSOR ON}
{$WARN UNSAFE_TYPE OFF}
{$WARN UNSAFE_CODE OFF}
{$WARN UNSAFE_CAST OFF}
{$WARN OPTION_TRUNCATED ON}
{$WARN WIDECHAR_REDUCED ON}
{$WARN DUPLICATES_IGNORED ON}
{$WARN UNIT_INIT_SEQ ON}
{$WARN LOCAL_PINVOKE ON}
{$WARN MESSAGE_DIRECTIVE ON}
{$WARN TYPEINFO_IMPLICITLY_ADDED ON}
{$WARN RLINK_WARNING ON}
{$WARN IMPLICIT_STRING_CAST ON}
{$WARN IMPLICIT_STRING_CAST_LOSS ON}
{$WARN EXPLICIT_STRING_CAST OFF}
{$WARN EXPLICIT_STRING_CAST_LOSS OFF}
{$WARN CVT_WCHAR_TO_ACHAR ON}
{$WARN CVT_NARROWING_STRING_LOST ON}
{$WARN CVT_ACHAR_TO_WCHAR ON}
{$WARN CVT_WIDENING_STRING_LOST ON}
{$WARN NON_PORTABLE_TYPECAST ON}
{$WARN XML_WHITESPACE_NOT_ALLOWED ON}
{$WARN XML_UNKNOWN_ENTITY ON}
{$WARN XML_INVALID_NAME_START ON}
{$WARN XML_INVALID_NAME ON}
{$WARN XML_EXPECTED_CHARACTER ON}
{$WARN XML_CREF_NO_RESOLVE ON}
{$WARN XML_NO_PARM ON}
{$WARN XML_NO_MATCHING_PARM ON}
{$WARN IMMUTABLE_STRINGS OFF}
unit LifeCel;

(* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. *)

interface

{define time}

uses
  Windows, Classes, Graphics, Controls, Dialogs, Forms, SysUtils,
  DDSurface, LifeConst
  {$ifdef time}
  ,TickTime
  {$endif}, LifeUtil, FastObject6;

    (*  group of Cells (lowest level):
         1 2
         3 4   = 2x2 Celen

        group of 2x2's:
         1 3
         2 4   = 4x4 Cells  (stored in 16-bit short)

        group of 4x4's:
         1 2
         3 4   = 8x8 Cels

        group of 8x8's:
         1 3
         2 4   = 16x16 Cels  (stored in LifeCel class)

        This means the bit-to-cell mapping is as follows:

         f  e  7  6  1f 1e 17 16 | 8f 8e 87 86  9f 9e 97 96
         d  c  5  4  1d 1c 15 14 | 8d 8c 85 84  9d 9c 95 94
         b  a  3  2  1b 1a 13 12 | 8b 8a 83 82  9b 9a 93 92
         9  8  1  0  19 18 11 10 | 89 88 81 80  99 98 91 90
                                 |
        2f 2e 27 26 3f 3e 37 36  | af ae a7 a6  bf be b7 b6
        2d 2c 25 24 3d 3c 35 34  | ad ac a5 a4  bd bc b5 b4
        2b 2a 23 22 3b 3a 33 32  | ab aa a3 a2  bb ba b3 b2
        29 28 21 20 39 38 31 30  | a9 a8 a1 a0  b9 b8 b1 b0
       __________________________|__________________________
                                 |
        4f 4e 47 46  5f 5e 57 56 | cf ce c7 c6  df de d7 d6
        4d 4c 45 44  5d 5c 55 54 | cd cc c5 c4  dd dc d5 d4
        4b 4a 43 42  5b 5a 53 52 | cb ca c3 c2  db da d3 d2
        49 48 41 40  59 58 51 50 | c9 c8 c1 c0  d9 d8 d1 d0
                                 |
        6f 7e 77 76  7f 7e 77 76 | ef ee e7 e6  ff fe f7 f6
        6d 7c 75 74  7d 7c 75 74 | ed ec e5 e4  fd fc f5 f4
        6b 7a 73 72  7b 7a 73 72 | eb ea e3 e2  fb fa f3 f2
        69 78 71 70  79 78 71 70 | e9 e8 e1 e0  f9 f8 f1 f0

        Note that 'f' is the most significant bit.

        Each of these 16 x 16 blocks has its own x,y coordinate
        in the universe, which are also saved as 16 bit shorts.
        Thus the universe size is 2^20 x 2^20 or a million x
        a million.

        In the p cycle, the real coordinates  are 16x, 16y.
        In the q cycle, the real coordinates  are 16x+1, 16y+1.

        This staggering occurs because the algorithm calls for
        calculating 4 Cels at a time by table lookup on the 4x4
        block surrounding it.  It is simply easier (read: faster)
        to stagger the cycles than it is to bit-shift all the time.

        p -> q:  Use p's S, E, SE blocks;
                 Affect q's S, E, SE blocks.

        q -> p:  Use q's N, W, NW blocks;
                 Affect p's N, W, NW blocks.    *)

type
  Tint = array[0..7] of integer;
  TSmall = array[0..15] of smallint;

  TRow = array[0..1] of integer;
  TColumn = array[0..3] of smallint;

  TCoor = record
    case boolean of
      true:(x,y: smallint);
      false:(xy: integer);
  end;


type
  PLifeCel = ^TLifeCel;
  //TLifeCel = class(TPersistent)
  TLifeCel = class(TFastObject)
  private
    function DifferenceWithQ: TSmall;
    function DifferenceWithP: TSmall;
    function ConvertQtoP: TSmall;

  public
    S, E, SE: TLifeCel;
    N, W, NW: TLifeCel;
    Next, Prev: TLifeCel;         //doubly linked.
    DisplayNext, DisplayPrev: TLifeCel;
    Down: TLifeCel;

    Coor: TCoor; //enables typecasting to 32-bit integer
    p: array[0..15] of smallint;
    q: array[0..15] of smallint;

    pstate, qstate: integer;

    //  bitmap:
    // |31 30 29 28.27 26 25 24|23 22 21 20.19 18 17 16|15 14 13 12.11 10  9  8| 7  6  5  4. 3  2  1  0|
    // | Northwest quadrant    | Southwest quadrant    | Northeast quadrant    | Southeast quadrant    |
    // | morgue    | hiber     | morgue    | hiber     | morgue    | hiber     | morgue    | hiber     |
    //
    // each group of 4 bits:
    // Whole 8x8 | Vertical 2x8 | Horizontal 8x2 | Corner 2x2

    flags: integer;
    //  bitmap:
    //  15 14 13 12.11 10  9  8. 7  6  5  4. 3  2  1  0
    //   |  |  |  |  |     |  |              |  |  |  Display (1=in)
    //   |  |  |  |  |     |  |              |  |  Morgue (1=in)
    //   |  |  |  |  |     |  |              |  Hibernation (1=in)
    //   |  |  |  |  |                       Morgue & displayed (incineratable)
    //   |  |  |  |  the Rattling bit
    //   |  |  |  q in hibernation
    //   |  |  q in morgue
    //   |  p in hibernation
    //   p in morgue



    destructor Destroy; override;
    {$WARN DUPLICATE_CTOR_DTOR OFF}
    destructor DestroySlow; virtual;
    {$WARN DUPLICATE_CTOR_DTOR ON}
    procedure FreeSlow;

    procedure DisplayOff;
    procedure DisplayOn;
    procedure DisplayAllOff;
    procedure DisplayAllOn;

    procedure DisplayZoom_1Off;
    procedure DisplayZoom_2Off;
    procedure DisplayZoom_3Off;
    procedure DisplayZoom_4Off;
    procedure DisplayZoom_5Off;
    procedure DisplayZoom_6Off;
    procedure DisplayZoom_7Off;
    procedure DisplayZoom_8Off;
    procedure DisplayZoom_1On;
    procedure DisplayZoom_2On;
    procedure DisplayZoom_3On;
    procedure DisplayZoom_4On;
    procedure DisplayZoom_5On;
    procedure DisplayZoom_6On;
    procedure DisplayZoom_7On;
    procedure DisplayZoom_8On;

    procedure DisplayDrag(XOffset, YOffset: Integer; DisplayQ: Boolean);
    procedure DisplayZoom_1Drag(XOffset, YOffset: Integer; DisplayQ: Boolean);
    procedure DisplayZoom_2Drag(XOffset, YOffset: Integer; DisplayQ: Boolean);
    procedure DisplayZoom_3Drag(XOffset, YOffset: Integer; DisplayQ: Boolean);
    procedure DisplayZoom_4Drag(XOffset, YOffset: Integer; DisplayQ: Boolean);
    procedure DisplayZoom_5Drag(XOffset, YOffset: Integer; DisplayQ: Boolean);
    procedure DisplayZoom_6Drag(XOffset, YOffset: Integer; DisplayQ: Boolean);
    procedure DisplayZoom_7Drag(XOffset, YOffset: Integer; DisplayQ: Boolean);
    procedure DisplayZoom_8Drag(XOffset, YOffset: Integer; DisplayQ: Boolean);
    function NumberOfCels(QCycle: Boolean): integer;
    function IsStable: boolean;
    function IsEmpty(QCycle: boolean): boolean;
    procedure FlipX(QCycle: LongBool);
    procedure FlipY(QCycle: LongBool);
    procedure BackFlip(QCycle: LongBool);

    procedure AssignTo(Dest: TPersistent); override;

    //procedure ClearRect(ARect: TRect; QCycle: boolean);
    function GetCelSum(QCycle: boolean): integer;
    function GetChecksum(QCycle: boolean): integer;
    function GetCelDiff(c2: TLifeCel; QCycle, QCycle2: boolean): integer;
    procedure Clear(QCycle: boolean);
    procedure FillBlack(QCycle: boolean);
    procedure Invert(QCycle: boolean);
    procedure DrawHorzLineRight(x1,y1: integer; State: TLineDrawState; QCycle: boolean);
    procedure DrawVertLineDown(x1,y1: integer; State: TLineDrawState; QCycle: boolean);
    procedure DrawHorzLineLeft(x1,y1: integer; State: TLineDrawState; QCycle: boolean);
    procedure DrawVertLineUp(x1,y1: integer; State: TLineDrawState; QCycle: boolean);
    procedure ExchangeTorusLineHorz(y1,y2: integer; c: TLifeCel; QCycle: boolean);
    procedure ExchangeTorusLineVert(x1,x2: integer; c: TLifeCel; QCycle: boolean);
    function TopRow(QCycle: boolean): integer;
    function BottomRow(QCycle: boolean): integer;
    function RightCol(QCycle: boolean): integer;
    function LeftCol(QCycle: boolean): integer;

    function GetARow(ARow: integer; QCycle: boolean): TRow;
    function GetAColumn(AColumn: integer; QCycle: boolean): TColumn;
    procedure ClearRow(Arow: integer; QCycle: boolean);
    procedure ClearColumn(AColumn: integer; QCycle: boolean);

    procedure Write(AStream: TStream; QCycle: boolean);
    procedure Read(AStream: TStream; QCycle: boolean);
  end;

  procedure SetBounds(AWindow: TControl; ARect: TRect);
  procedure SetDisplayProps(XOrig, YOrig,ox,oy, NegZoom: integer;
                            DisplayQGen: Boolean);
  procedure SetCelSpace(ACelSpace: integer; GridOn: Boolean);
  procedure InitDDraw;
  procedure DisplayChange(BitsPerPixel,Width,Height: integer);

var
  MyDDSurface: TMyDDSurface;


var
  BackColor: TColor = TColor($FFFFFFFF);
  ForeColor: TColor = $00000000; //colors for 256 color mode only //just testing now.
  DragColor: TColor = TColor($FFFFFFFF);
  TorusColor: TColor = $00000000;

{$ifdef time}
var
  CumDisp: Comp;
  CumDiff: Comp;
{$endif}

implementation

{$ifdef time}
uses Unit1;
{$endif}

//Global vars
var
  CelSpace: Integer;
  CelSpace2: Integer;
  CelSpace4: Integer;
  CelSpace8: Integer;
  CelSpace12: Integer;
  CelSpace16: Integer;
  CelSize: Integer;
  DrawBound: TRect;
  StartPoint: TPoint;
  DisplayQ: Boolean;
  CenterX, CenterY: integer;
  XorigDiv16, YOrigDiv16: integer;
  RestOfXOrig, RestOfYOrig: integer;


destructor TLifeCel.Destroy;
var
  i: integer;
begin
  (*if assigned(S) then S.N:= nil;
  if assigned(E) then E.W:= nil;
  if assigned(SE) then SE.NW:= nil;
  if assigned(N) then N.S:= nil;
  if assigned(W) then W.E:= nil;
  if assigned(NW) then NW.SE:= nil;
  Next.Prev:= Prev; //always <> nil.
  Prev.Next:= Next; //always <> nil.
  DisplayPrev.DisplayNext:= DisplayNext; //always assigned.
  DisplayNext.DisplayPrev:= DisplayPrev; //always assigned.
  {Down is NOT updated, and doesn't have to btw}
  //Clear data
  Flags:= 0;
  PState:= 0;
  QState:= 0;

  inherited Destroy; (**)
  if assigned(S) then S.N:= nil;
  if assigned(E) then E.W:= nil;
  if assigned(SE) then SE.NW:= nil;
  if assigned(N) then N.S:= nil;
  if assigned(W) then W.E:= nil;
  if assigned(NW) then NW.SE:= nil;
  Next.Prev:= Prev; //always <> nil.
  Prev.Next:= Next; //always <> nil.
  DisplayPrev.DisplayNext:= DisplayNext; //always assigned.
  DisplayNext.DisplayPrev:= DisplayPrev; //always assigned.
  {Down is NOT updated, and doesn't have to btw}
  //Clear all data (except Self, hence the -4).
  i:= Self.InstanceSize-4;
  FillChar(S,i,0);

  inherited Destroy;
end;

destructor TLifeCel.DestroySlow;
var
  i: integer;
begin
  if assigned(S) then S.N:= nil;
  if assigned(E) then E.W:= nil;
  if assigned(SE) then SE.NW:= nil;
  if assigned(N) then N.S:= nil;
  if assigned(W) then W.E:= nil;
  if assigned(NW) then NW.SE:= nil;
  Next.Prev:= Prev; //always <> nil.
  Prev.Next:= Next; //always <> nil.
  DisplayPrev.DisplayNext:= DisplayNext; //always assigned.
  DisplayNext.DisplayPrev:= DisplayPrev; //always assigned.
  {Down is NOT updated, and doesn't have to btw}
  //Clear all data (except Self, hence the -4).
  i:= Self.InstanceSize-4;
  FillChar(S,i,0);

  inherited Destroy;
end;

procedure TLifeCel.FreeSlow;
begin
  if self <> nil then DestroySlow;
end;



//This routine does a lot of swapping:
//First: the celbits: fe76 are converted to 67ef.
//                    dc54                  45cd.
//                    ba32                  ab23.
//                    9810                  0189.
//then smallint 0 and 1 are swapped and then 01 and 89 etc are swapped.
//after all this the entire Cel is converted to it's X-mirrored image.
procedure TLifeCel.FlipX(Qcycle: LongBool);
begin
  //Self will be in EAX and QCycle will be in EDX.
  asm
    push ebx
    lea ecx,[eax+TLifeCel.p];
    mov bx,[eax+TLifeCel.coor.x];
    neg ebx
    mov [eax+TLifeCel.coor.x],bx
    or  edx,edx
    jz  @@PCycle
@@QCycle:
    lea ecx,[eax+TLifeCel.q]
@@PCycle://now ecx points to start of relevant celdata.
@@DWords0189:
    mov edx,[ecx]
    mov ebx,[ecx]
    and edx,$aaaaaaaa //4x 10101010
    and ebx,$55555555 //4x 01010101
    ror edx,9         //                0000000000000000-1111111111111111
    ror ebx,7         //conversion from fedcba9876543210-fedcba9876543210
    or  edx,ebx       //to:             1111111100000000-0000000011111111
                      //                67452301efcdab89-67452301efcdab89
    mov ebx,edx
    and edx,$FF00FF00
    and ebx,$00ff00ff
    ror ebx,16        //and to:         1111111111111111-0000000000000000
    or  ebx,edx       //                67452301efcdab89-67452301efcdab89
    mov edx,[ecx+2*8] //get Block 8,9
    mov [ecx+2*8],ebx //swap 0,1 and 8,9 and repeat this procedure.
    mov ebx,edx
    and edx,$aaaaaaaa //4x 10101010
    and ebx,$55555555 //4x 01010101
    ror edx,9         //                0000000000000000-1111111111111111
    ror ebx,7         //conversion from fedcba9876543210-fedcba9876543210
    or  edx,ebx       //to:             1111111100000000-0000000011111111
                      //                67452301efcdab89-67452301efcdab89
    lea ecx,[ecx+4]   //next dword.
    mov ebx,edx
    and edx,$FF00FF00
    and ebx,$00ff00ff
    ror ebx,16        //and to:         1111111111111111-0000000000000000
    or  edx,ebx       //                67452301efcdab89-67452301efcdab89
    mov [ecx-4],edx
@@DWords23ab:
    mov edx,[ecx]
    mov ebx,[ecx]
    and edx,$aaaaaaaa //4x 10101010
    and ebx,$55555555 //4x 01010101
    ror edx,9         //                0000000000000000-1111111111111111
    ror ebx,7         //conversion from fedcba9876543210-fedcba9876543210
    or  edx,ebx       //to:             1111111100000000-0000000011111111
                      //                67452301efcdab89-67452301efcdab89
    mov ebx,edx
    and edx,$FF00FF00
    and ebx,$00ff00ff
    ror ebx,16        //and to:         1111111111111111-0000000000000000
    or  ebx,edx       //                67452301efcdab89-67452301efcdab89
    mov edx,[ecx+2*8] //get Block 8,9
    mov [ecx+2*8],ebx //swap 0,1 and 8,9 and repeat this procedure.
    mov ebx,edx
    and edx,$aaaaaaaa //4x 10101010
    and ebx,$55555555 //4x 01010101
    ror edx,9         //                0000000000000000-1111111111111111
    ror ebx,7         //conversion from fedcba9876543210-fedcba9876543210
    or  edx,ebx       //to:             1111111100000000-0000000011111111
                      //                67452301efcdab89-67452301efcdab89
    lea ecx,[ecx+4]   //next dword.
    mov ebx,edx
    and edx,$FF00FF00
    and ebx,$00ff00ff
    ror ebx,16        //and to:         1111111111111111-0000000000000000
    or  edx,ebx       //                67452301efcdab89-67452301efcdab89
    mov [ecx-4],edx

@@DWords45cd:
    mov edx,[ecx]
    mov ebx,edx
    and edx,$aaaaaaaa //4x 10101010
    and ebx,$55555555 //4x 01010101
    ror edx,9         //                0000000000000000-1111111111111111
    ror ebx,7         //conversion from fedcba9876543210-fedcba9876543210
    or  edx,ebx       //to:             1111111100000000-0000000011111111
                      //                67452301efcdab89-67452301efcdab89
    mov ebx,edx
    and edx,$FF00FF00
    and ebx,$00ff00ff
    ror ebx,16        //and to:         1111111111111111-0000000000000000
    or  ebx,edx       //                67452301efcdab89-67452301efcdab89
    mov edx,[ecx+2*8] //get Block 8,9
    mov [ecx+2*8],ebx //swap 0,1 and 8,9 and repeat this procedure.
    mov ebx,edx
    and edx,$aaaaaaaa //4x 10101010
    and ebx,$55555555 //4x 01010101
    ror edx,9         //                0000000000000000-1111111111111111
    ror ebx,7         //conversion from fedcba9876543210-fedcba9876543210
    or  edx,ebx       //to:             1111111100000000-0000000011111111
                      //                67452301efcdab89-67452301efcdab89
    lea ecx,[ecx+4]   //next dword.
    mov ebx,edx
    and edx,$FF00FF00
    and ebx,$00ff00ff
    ror ebx,16        //and to:         1111111111111111-0000000000000000
    or  edx,ebx       //                67452301efcdab89-67452301efcdab89
    mov [ecx-4],edx

@@DWords67ef:
    mov edx,[ecx]
    mov ebx,edx
    and edx,$aaaaaaaa //4x 10101010
    and ebx,$55555555 //4x 01010101
    ror edx,9         //                0000000000000000-1111111111111111
    ror ebx,7         //conversion from fedcba9876543210-fedcba9876543210
    or  edx,ebx       //to:             1111111100000000-0000000011111111
                      //                67452301efcdab89-67452301efcdab89
    mov ebx,edx
    and edx,$FF00FF00
    and ebx,$00ff00ff
    ror ebx,16        //and to:         1111111111111111-0000000000000000
    or  ebx,edx       //                67452301efcdab89-67452301efcdab89
    mov edx,[ecx+2*8] //get Block 8,9
    mov [ecx+2*8],ebx //swap 0,1 and 8,9 and repeat this procedure.
    mov ebx,edx
    and edx,$aaaaaaaa //4x 10101010
    and ebx,$55555555 //4x 01010101
    ror edx,9         //                0000000000000000-1111111111111111
    ror ebx,7         //conversion from fedcba9876543210-fedcba9876543210
    or  edx,ebx       //to:             1111111100000000-0000000011111111
                      //                67452301efcdab89-67452301efcdab89
    mov ebx,edx
    and edx,$FF00FF00
    and ebx,$00ff00ff
    ror ebx,16        //and to:         1111111111111111-0000000000000000
    or  edx,ebx       //                67452301efcdab89-67452301efcdab89
    mov [ecx],edx

    pop ebx
  end; {asm}
end;


procedure TLifeCel.FlipY(QCycle: LongBool);
begin
  asm
    push edi
    push esi
    lea ecx,[eax+TLifeCel.p];
    mov di,[eax+TLifeCel.coor.y];
    neg edi
    mov [eax+TLifeCel.coor.y],di
    or  edx,edx
    jz  @@PCycle
@@QCycle:
    lea ecx,[eax+TLifeCel.q]
@@PCycle://now ecx points to start of relevant celdata.
@@DWords01:
    mov edx,[ecx+0*2]
    mov esi,edx
    mov edi,edx
    and esi,$30303030  //4 x 00110000
    shr esi,2
    and edi,$c0c0c0c0  //4 x 11000000
    shr edi,6
    mov eax,esi
    or  eax,edi
    mov esi,edx
    mov edi,edx
    and esi,$03030303  //4 x 00000011
    shl esi,6
    and edi,$0c0c0c0c
    shl edi,2
    or  eax,esi
    or  eax,edi
    mov edx,[ecx+6*2]
    mov [ecx+6*2],eax
@@DWords67:
    mov esi,edx
    mov edi,edx
    and esi,$30303030  //4 x 00110000
    shr esi,2
    and edi,$c0c0c0c0  //4 x 11000000
    shr edi,6
    mov eax,esi
    or  eax,edi
    mov esi,edx
    mov edi,edx
    and esi,$03030303  //4 x 00000011
    shl esi,6
    and edi,$0c0c0c0c
    shl edi,2
    or  eax,esi
    or  eax,edi
    mov edx,[ecx+2*2]
    mov [ecx],eax

@@DWords23:
    mov esi,edx
    mov edi,edx
    and esi,$30303030  //4 x 00110000
    shr esi,2
    and edi,$c0c0c0c0  //4 x 11000000
    shr edi,6
    mov eax,esi
    or  eax,edi
    mov esi,edx
    mov edi,edx
    and esi,$03030303  //4 x 00000011
    shl esi,6
    and edi,$0c0c0c0c
    shl edi,2
    or  eax,esi
    or  eax,edi
    mov edx,[ecx+4*2]
    mov [ecx+4*2],eax
@@DWords45:
    mov esi,edx
    mov edi,edx
    and esi,$30303030  //4 x 00110000
    shr esi,2
    and edi,$c0c0c0c0  //4 x 11000000
    shr edi,6
    mov eax,esi
    or  eax,edi
    mov esi,edx
    mov edi,edx
    and esi,$03030303  //4 x 00000011
    shl esi,6
    and edi,$0c0c0c0c
    shl edi,2
    or  eax,esi
    or  eax,edi
    mov edx,[ecx+8*2]
    mov [ecx+2*2],eax

@@DWords89:
    mov esi,edx
    mov edi,edx
    and esi,$30303030  //4 x 00110000
    shr esi,2
    and edi,$c0c0c0c0  //4 x 11000000
    shr edi,6
    mov eax,esi
    or  eax,edi
    mov esi,edx
    mov edi,edx
    and esi,$03030303  //4 x 00000011
    shl esi,6
    and edi,$0c0c0c0c
    shl edi,2
    or  eax,esi
    or  eax,edi
    mov edx,[ecx+14*2]
    mov [ecx+14*2],eax
@@DWordsEF:
    mov esi,edx
    mov edi,edx
    and esi,$30303030  //4 x 00110000
    shr esi,2
    and edi,$c0c0c0c0  //4 x 11000000
    shr edi,6
    mov eax,esi
    or  eax,edi
    mov esi,edx
    mov edi,edx
    and esi,$03030303  //4 x 00000011
    shl esi,6
    and edi,$0c0c0c0c
    shl edi,2
    or  eax,esi
    or  eax,edi
    mov edx,[ecx+10*2]
    mov [ecx+8*2],eax

@@DWordsAB:
    mov esi,edx
    mov edi,edx
    and esi,$30303030  //4 x 00110000
    shr esi,2
    and edi,$c0c0c0c0  //4 x 11000000
    shr edi,6
    mov eax,esi
    or  eax,edi
    mov esi,edx
    mov edi,edx
    and esi,$03030303  //4 x 00000011
    shl esi,6
    and edi,$0c0c0c0c
    shl edi,2
    or  eax,esi
    or  eax,edi
    mov edx,[ecx+12*2]
    mov [ecx+12*2],eax
@@DWordsCD:
    mov esi,edx
    mov edi,edx
    and esi,$30303030  //4 x 00110000
    shr esi,2
    and edi,$c0c0c0c0  //4 x 11000000
    shr edi,6
    mov eax,esi
    or  eax,edi
    mov esi,edx
    mov edi,edx
    and esi,$03030303  //4 x 00000011
    shl esi,6
    and edi,$0c0c0c0c
    shl edi,2
    or  eax,esi
    or  eax,edi
    mov [ecx+10*2],eax
    pop esi
    pop edi
  end; {asm}
end;


procedure TLifeCel.BackFlip(QCycle: longBool);
begin
  asm
    push ebx
    push edi
    push esi
    lea ecx,[eax+TLifeCel.p];  //ecx:= @p;
    mov di,[eax+TLifeCel.coor.y];
    neg edi
    mov si,[eax+TLifeCel.coor.x];
    mov [eax+TLifeCel.coor.x],di    //x:= -y;
    neg esi
    mov [eax+TLifeCel.coor.y],si;   //y:= -x;
    or  edx,edx
    jz  @@PCycle               //if QCycle then ecx:= @Q;
@@QCycle:
    lea ecx,[eax+TLifeCel.q]
@@PCycle://now ecx points to start of relevant celdata.
@@DWords01:
    mov edx,[ecx+0*2]         //edx:= TInt(p)[0];
    mov edi,edx               //edi:= edx;
    mov esi,edx               //esi:= edx;
    and edi,$80008000         //fedcba9876543210    02138a9b4657cedf.
    shr edi,15                //f--------------- => ---------------f.
    and esi,$60006000
    shr esi,12                //-ed------------- => -------------ed-.
    mov eax,edi
    or  eax,esi
    mov edi,edx
    mov esi,edx
    and edi,$10001000
    shr edi,$9                //---c------------ => ------------c---.
    and esi,$08800880
    shr esi,3                 //----b---7------- => -------b---7----.
    or  eax,edi
    or  eax,esi
    mov edi,edx
    mov esi,edx
    and edi,$01100110
    shl edi,3                 //-------8---4---- => ----8---4-------.
    and esi,$00080008
    shl esi,9                 //------------3--- => ---3------------.
    or  eax,edi
    or  eax,esi

    mov edi,edx
    mov esi,edx
    and edi,$00060006
    shl edi,12                //-------------21- => -21-------------.
    and esi,$00010001
    shl esi,15                //---------------0 => 0---------------.
    and edx,$06600660         //-----a9--65----- => -----a9--65-----.
    or  eax,edi               //====================================.
    or  eax,esi               //fedcba9876543210 => 02138a9b4657cedf.
    or  eax,edx
@@DWords23:
    mov edx,[ecx+2*2]
    mov edi,edx
    mov esi,edx
    and edi,$80008000
    shr edi,15
    and esi,$60006000
    shr esi,12
    mov ebx,edi
    or  ebx,esi
    mov edi,edx
    mov esi,edx
    and edi,$10001000
    shr edi,9
    and esi,$08800880
    shr esi,3
    or  ebx,edi
    or  ebx,esi
    mov edi,edx
    mov esi,edx
    and edi,$01100110
    shl edi,3
    and esi,$00080008
    shl esi,9
    or  ebx,edi
    or  ebx,esi

    mov edi,edx
    mov esi,edx
    and edi,$00060006
    shl edi,12
    and esi,$00010001
    shl esi,15
    and edx,$06600660
    or  ebx,edi
    or  ebx,esi
    or  ebx,edx
@@Mix0123:
    ror ebx,16  //01 -> 01 -> 31 -> 31  (eax)
    xchg ax,bx  //23 -> 32 -> 02 -> 20  (ebx)
    ror ebx,16
    push eax
    push ebx
@@DWordsCD:
    mov edx,[ecx+$C*2]
    mov edi,edx
    mov esi,edx
    and edi,$80008000
    shr edi,15
    and esi,$60006000
    shr esi,12
    mov eax,edi
    or  eax,esi
    mov edi,edx
    mov esi,edx
    and edi,$10001000
    shr edi,9
    and esi,$08800880
    shr esi,3
    or  eax,edi
    or  eax,esi
    mov edi,edx
    mov esi,edx
    and edi,$01100110
    shl edi,3
    and esi,$00080008
    shl esi,9
    or  eax,edi
    or  eax,esi

    mov edi,edx
    mov esi,edx
    and edi,$00060006
    shl edi,12
    and esi,$00010001
    shl esi,15
    and edx,$06600660
    or  eax,edi
    or  eax,esi
    or  eax,edx
@@DWordsEF:
    mov edx,[ecx+$E*2]
    mov edi,edx
    mov esi,edx
    and edi,$80008000
    shr edi,15
    and esi,$60006000
    shr esi,12
    mov ebx,edi
    or  ebx,esi
    mov edi,edx
    mov esi,edx
    and edi,$10001000
    shr edi,9
    and esi,$08800880
    shr esi,3
    or  ebx,edi
    or  ebx,esi
    mov edi,edx
    mov esi,edx
    and edi,$01100110
    shl edi,3
    and esi,$00080008
    shl esi,9
    or  ebx,edi
    or  ebx,esi

    mov edi,edx
    mov esi,edx
    and edi,$00060006
    shl edi,12
    and esi,$00010001
    shl esi,15
    and edx,$06600660
    or  ebx,edi
    or  ebx,esi
    or  ebx,edx
@@MixCDEF:
    ror ebx,16  //CD -> CD -> FD -> FD (eax)
    xchg ax,bx  //EF -> FE -> CE -> EC (ebx).
    ror ebx,16
    mov [ecx+0*2],eax
    mov [ecx+2*2],ebx
    pop ebx
    pop eax
    mov [ecx+$e*2],ebx
    mov [ecx+$c*2],eax
@@DWords45:
    mov edx,[ecx+4*2]
    mov edi,edx
    mov esi,edx
    and edi,$80008000
    shr edi,15
    and esi,$60006000
    shr esi,12
    mov eax,edi
    or  eax,esi
    mov edi,edx
    mov esi,edx
    and edi,$10001000
    shr edi,9
    and esi,$08800880
    shr esi,3
    or  eax,edi
    or  eax,esi
    mov edi,edx
    mov esi,edx
    and edi,$01100110
    shl edi,3
    and esi,$00080008
    shl esi,9
    or  eax,edi
    or  eax,esi

    mov edi,edx
    mov esi,edx
    and edi,$00060006
    shl edi,12
    and esi,$00010001
    shl esi,15
    and edx,$06600660
    or  eax,edi
    or  eax,esi
    or  eax,edx
@@DWords67:
    mov edx,[ecx+6*2]
    mov edi,edx
    mov esi,edx
    and edi,$80008000
    shr edi,15
    and esi,$60006000
    shr esi,12
    mov ebx,edi
    or  ebx,esi
    mov edi,edx
    mov esi,edx
    and edi,$10001000
    shr edi,9
    and esi,$08800880
    shr esi,3
    or  ebx,edi
    or  ebx,esi
    mov edi,edx
    mov esi,edx
    and edi,$01100110
    shl edi,3
    and esi,$00080008
    shl esi,9
    or  ebx,edi
    or  ebx,esi

    mov edi,edx
    mov esi,edx
    and edi,$00060006
    shl edi,12
    and esi,$00010001
    shl esi,15
    and edx,$06600660
    or  ebx,edi
    or  ebx,esi
    or  ebx,edx
@@Mix4567:
    ror ebx,16  //45 -> 45 -> 75 -> 75  (eax)
    xchg ax,bx  //67 -> 76 -> 46 -> 64  (ebx)
    ror ebx,16
    mov [ecx+4*2],eax
    mov [ecx+6*2],ebx

@@DWords89:
    mov edx,[ecx+8*2]
    mov edi,edx
    mov esi,edx
    and edi,$80008000
    shr edi,15
    and esi,$60006000
    shr esi,12
    mov eax,edi
    or  eax,esi
    mov edi,edx
    mov esi,edx
    and edi,$10001000
    shr edi,9
    and esi,$08800880
    shr esi,3
    or  eax,edi
    or  eax,esi
    mov edi,edx
    mov esi,edx
    and edi,$01100110
    shl edi,3
    and esi,$00080008
    shl esi,9
    or  eax,edi
    or  eax,esi

    mov edi,edx
    mov esi,edx
    and edi,$00060006
    shl edi,12
    and esi,$00010001
    shl esi,15
    and edx,$06600660
    or  eax,edi
    or  eax,esi
    or  eax,edx
@@DWordsab:
    mov edx,[ecx+$a*2]
    mov edi,edx
    mov esi,edx
    and edi,$80008000
    shr edi,15
    and esi,$60006000
    shr esi,12
    mov ebx,edi
    or  ebx,esi
    mov edi,edx
    mov esi,edx
    and edi,$10001000
    shr edi,9
    and esi,$08800880
    shr esi,3
    or  ebx,edi
    or  ebx,esi
    mov edi,edx
    mov esi,edx
    and edi,$01100110
    shl edi,3
    and esi,$00080008
    shl esi,9
    or  ebx,edi
    or  ebx,esi

    mov edi,edx
    mov esi,edx
    and edi,$00060006
    shl edi,12
    and esi,$00010001
    shl esi,15
    and edx,$06600660
    or  ebx,edi
    or  ebx,esi
    or  ebx,edx
@@Mix89ab:
    ror ebx,16  //89 -> 89 -> b9 -> b9  (eax)
    xchg ax,bx  //ab -> ba -> 8a -> a8  (ebx)
    ror ebx,16
    mov [ecx+8*2],eax
    mov [ecx+10*2],ebx
    pop esi
    pop edi
    pop ebx
  end; {asm}
end;

procedure TLifeCel.AssignTo(Dest: TPersistent);
var
  OldFlags: integer;
begin
  if Dest is TLifeCel then begin
    TLifeCel(Dest).coor.xy:= coor.xy;
    TLifeCel(Dest).p:= p;
    TLifeCel(Dest).q:= q;

    TLifeCel(Dest).pstate:= pstate;
    TLifeCel(Dest).qstate:= qstate;

    //copy flags, but keep displayflag of Dest.
    OldFlags:= TLifeCel(Dest).Flags and 1;
    TLifeCel(Dest).flags:= (Flags or OldFlags);
  end
  else inherited AssignTo(Dest);
end;




//           P0 P1    P8    P9   P10
//01|89      P2 P3Q0  PaQ1  PbQ8 P12Q9.
//23|AB      P4 P5Q2  PcQ3  PdQa P14Qb.
//--+--      P6 P7Q4  PeQ5  PfQc P16Qd.
//45|CD        P21Q6 P28Q7 P29Qe P30Qf.
//67|EF

{This is NOT an easy routine to understand, but what it does is basicly simple.
 It calculates the difference between the cel in it's Q-cycle and the underlying
 P-cycle.
 Since the P-cycle is shifted to the NW. the Q-cycle lays on top of the P-cycle
 in the Middle, East, South en SouthEast sectors of that P-cycle.
 this matches a0,a1,a2,a3 in that same order.
 a1 and a3 are not used in this routine because I've spliced them together with
 a0 and a2 respectivly.
 This routine takes a snapshot of the underlying P-Cycle. Then shifts the bits
 around, to make them look as if it was a Q-cycle. That result is Xor'ed with
 the current (Q)cycle to get the difference. The display routine then looks at
 the bits that where gained, these go into 'Onn' (on is a reserved word), the
 bits that where lost are not'ed and go into 'Off'.
 To speed things up a bit (130% compared to the 16 bit version) I do 2 words at
 a time.}

function TLifeCel.DifferenceWithP: TSmall;  {version with full 32bit logic}
const
  Mask0 = $3f3f153f;
  Mask1 = $00002a00;
  Mask2 = $c0c040c0;
  Mask3 = $00008000;
begin
  asm
  //00000000000000000000000000000000000000000000000000000000000000000000
  //a0:= TInt(p)[0] and Mask0;
  //a0:= a0 or (TInt(p)[4] and Mask1);
  //a2:= TInt(p)[1] and Mask2;
  //a2:= a2 or (TInt(p)[5] and Mask3);
    push ebx                                //u
    push esi                                //v
    push edi                                //u
    mov ecx,dword ptr [eax+TLifeCel.p+0]    //v
    mov ebx,dword ptr [eax+TLifeCel.p+4*4]  //u
    and ecx,Mask0                           //v
    and ebx,Mask1                           //u
    mov esi,dword ptr [eax+TLifeCel.p+5*4]  //v
    or ecx,ebx                              //u
    mov ebx,dword ptr [eax+TLifeCel.p+4]    //v
    and esi,Mask3                           //u
    and ebx,Mask2                           //v
    or ebx,esi                              //u  <<--no delay,b'caus new cycle
  //a0:=((a0 and $15151515) shl 3) or //F-D- B--- 7-5- 3---|f-d- b--- 7-5- 3---
  //    ((a0 and $002a2a2a) shl 9) or //-E-C -A-- -6-4 -2--|-e-c a--- ---- ----
  //    ((a0 and $2a000000) shr 23);  //---- ---- ---- ----|---- ---- -6-4 -2--
  //a2:=((a2 and $40404040) shr 5) or //---- --9- ---- --1-|---- --9- ---- --1-
  //    ((a2 and $00808080) shl 1) or //---- ---8 ---- ---0|---- ---8 ---- ----
  //    ((a2 and $80000000) shr 31);  //---- ---- ---- ----|---- ---- ---- ---0
    mov esi,ecx         //v
    and ecx,$2a2a2a2a   //u
    and esi,$15151515   //v
    rol ecx,9           //u  <<-- rcl can't run in v-pipe (does pair however).
    mov edi,ebx         //v
    and ebx,$80808080   //u  <<-- ecx:= ecx or (esi shl 3)
    and edi,$40404040   //v
    rol ebx,1           //u
    lea ecx,[ecx+esi*8] //v
    shr edi,5           //u
    mov esi,dword ptr [eax+TLifeCel.q] //v
    or  ebx,edi         //u

  //TInt(Result)[0]:= (a0 or a2) xor TInt(q)[0];
    mov edi,dword ptr [eax+TLifeCel.p+1*4] //v
    or  ecx,ebx                            //u
    mov ebx,dword ptr [eax+TLifeCel.p+5*4] //v
    xor esi,ecx                            //u
    and edi,Mask0                          //v
    mov [edx],esi                          //u

  //1111111111111111111111111111111111111111111111111111111111111
  //a0:= TInt(p)[1] and Mask0;
  //a0:= a0 or (TInt(p)[5] and Mask1);
  //a2:= TInt(p)[2] and Mask2;
  //a2:= a2 or (TInt(p)[6] and Mask3);
    and ebx,Mask1                          //v
    mov esi,dword ptr [eax+TLifeCel.p+6*4] //u
    or  edi,ebx                            //v
    mov ebx,dword ptr [eax+TLifeCel.p+2*4] //u
    and esi,Mask3                          //v
    and ebx,Mask2                          //u
    mov ecx,edi                            //v
    or  ebx,esi                            //u
  //a0:=((a0 and $15151515) shl 3) or //F-D- B--- 7-5- 3---|f-d- b--- 7-5- 3---
  //    ((a0 and $002a2a2a) shl 9) or //-E-C -A-- -6-4 -2--|-e-c a--- ---- ----
  //    ((a0 and $2a000000) shr 23);  //---- ---- ---- ----|---- ---- -6-4 -2--
  //a2:=((a2 and $40404040) shr 5) or //---- --9- ---- --1-|---- --9- ---- --1-
  //    ((a2 and $00808080) shl 1) or //---- ---8 ---- ---0|---- ---8 ---- ----
  //    ((a2 and $80000000) shr 31);  //---- ---- ---- ----|---- ---- ---- ---0
    and ecx,$2a2a2a2a    //v
    rol ecx,9            //u
    and edi,$15151515    //v
    mov esi,ebx          //u
    and ebx,$80808080    //v
    rol ebx,1            //u
    and esi,$40404040    //v
    shr esi,5            //u
    lea ecx,[ecx+edi*8]  //v << ecx:= ecx or (edi shl 3)
    or  ebx,esi          //u
    mov edi,dword ptr [eax+TLifeCel.q+1*4] //v
  //TInt(Result)[1]:= (a0 or a2) xor TInt(q)[1];
    or  ecx,ebx                            //u
    mov ebx,dword ptr [eax+TLifeCel.p+6*4] //v
    xor edi,ecx                            //u
    mov ecx,dword ptr [eax+TLifeCel.p+2*4] //v
    mov [edx+1*4],edi                      //u

  //a0:= TInt(p)[2] and Mask0;
  //a0:= a0 or (TInt(p)[6] and Mask1);
  //a2:= TInt(p)[3] and Mask2;
  //a2:= a2 or (TInt(p)[7] and Mask3);
    and ecx,Mask0                          //v
    and ebx,Mask1                          //u
    mov esi,dword ptr [eax+TLifeCel.p+7*4] //v
    or  ecx,ebx                            //u
    mov ebx,dword ptr [eax+TLifeCel.p+3*4] //v
    and esi,Mask3                          //u
    and ebx,Mask2                          //v
    or  ebx,esi                            //u  <<-- new cycle no dep.
  //a0:=((a0 and $15151515) shl 3) or //F-D- B--- 7-5- 3---|f-d- b--- 7-5- 3---
  //    ((a0 and $002a2a2a) shl 9) or //-E-C -A-- -6-4 -2--|-e-c a--- ---- ----
  //    ((a0 and $2a000000) shr 23);  //---- ---- ---- ----|---- ---- -6-4 -2--
  //a2:=((a2 and $40404040) shr 5) or //---- --9- ---- --1-|---- --9- ---- --1-
  //    ((a2 and $00808080) shl 1) or //---- ---8 ---- ---0|---- ---8 ---- ----
  //    ((a2 and $80000000) shr 31);  //---- ---- ---- ----|---- ---- ---- ---0
    mov esi,ecx            //v
    shl esi,3              //u
    and ecx,$2a2a2a2a      //v
    rol ecx,9              //u
    and esi,$a8a8a8a8      //v
    mov edi,ebx            //u
    and edi,$40404040      //v
    shr edi,5              //u
    and ebx,$80808080      //v
    rol ebx,1              //u
    lea ecx,[ecx+esi]      //v
    or  ebx,edi            //u
    mov edi,dword ptr [eax+TLifeCel.q+2*4] //v
  //TInt(Result)[2]:= (a0 or a2) xor TInt(q)[2];
    or  ecx,ebx                            //u
    mov ebx,dword ptr [eax+TLifeCel.p+7*4] //v
    xor edi,ecx                            //u
    mov ecx,dword ptr [eax+TLifeCel.p+3*4] //v
    mov [edx+2*4],edi                      //u


  //333333333333333333333333333333333333333333333333333333333
  //a0:= TInt(p)[3] and Mask0;
  //a0:= a0 or (TInt(p)[7] and Mask1);
    and ecx,Mask0              //v
    and ebx,Mask1              //u
    mov esi,[eax+TLifeCel.S]   //v
    or  ecx,ebx                //u
  //if Assigned(S) then begin
    test esi,esi               //v
    mov ebx,0                  //u <-- free 'cause je can only pair in v-pipe
    je  @@ThreeNoS             //v + extra jump saved. mov saves regs.
  //  a2:= TInt(S.p)[0] and Mask2;
  //  a2:= a2 or (TInt(S.p)[4] and Mask3);
    mov ebx,dword ptr [esi+TLifeCel.p+0*4] //u
    mov esi,dword ptr [esi+TLifeCel.p+4*4] //v
    and ebx,Mask2                          //u
    and esi,Mask3                          //v
@@ThreeNoS:                                // <- label's here 'cause or 0,0 = 0.
    or  ebx,esi                            //u <- now I always know which pipe
  //end {if}                                   <- I'm in, after jmp always in u.
  //else begin a2:= 0; end; {else}


  //a0:=((a0 and $15151515) shl 3) or //F-D- B--- 7-5- 3---|f-d- b--- 7-5- 3---
  //    ((a0 and $002a2a2a) shl 9) or //-E-C -A-- -6-4 -2--|-e-c a--- ---- ----
  //    ((a0 and $2a000000) shr 23);  //---- ---- ---- ----|---- ---- -6-4 -2--
  //a2:=((a2 and $40404040) shr 5) or //---- --9- ---- --1-|---- --9- ---- --1-
  //    ((a2 and $00808080) shl 1) or //---- ---8 ---- ---0|---- ---8 ---- ----
  //    ((a2 and $80000000) shr 31);  //---- ---- ---- ----|---- ---- ---- ---0
    mov esi,ecx          //v
    shl esi,3            //u
    and ecx,$2a2a2a2a    //v
    rol ecx,9            //u
    and esi,$a8a8a8a8    //v
    or  ecx,esi          //u

    mov esi,ebx          //v
    rol ebx,1            //u
    and esi,$40404040    //v
    shr esi,5            //u
    and ebx,$01010101    //v
    or  ebx,esi          //u
    mov edi,dword ptr [eax+TLifeCel.q+3*4] //v
  //TInt(Result)[3]:= (a0 or a2) xor TInt(q)[3];
    or  ecx,ebx                            //u
    mov ebx,dword ptr [eax+TLifeCel.p+5*4] //v
    xor edi,ecx                            //u
    mov ecx,dword ptr [eax+TLifeCel.p+4*4] //v
    mov [edx+3*4],edi                      //u

  //4444444444444444444444444444444444444444444444444
  //a0:= TInt(p)[4] and Mask0;
  //a2:= TInt(p)[5] and Mask2;
    and ecx,Mask0            //v
    and ebx,Mask2            //u
  //if Assigned(E) then begin
    mov esi,[eax+TLifeCel.E] //v
    test esi,esi             //u
    je  @@FourNoS            //v
  //  a0:= a0 or (TInt(E.p)[0] and Mask1);
  //  a2:= a2 or (TInt(E.p)[1] and Mask3);
    mov edi,dword ptr [esi+TLifeCel.p+0*4]  //u
    mov esi,dword ptr [esi+TLifeCel.p+1*4]  //v
    and edi,Mask1                           //u
    and esi,Mask3                           //v
    or  ecx,edi                             //u
    or  ebx,esi                             //v
  //end; {if}
@@FourNoS:
  //a0:=((a0 and $15151515) shl 3) or //F-D- B--- 7-5- 3---|f-d- b--- 7-5- 3---
  //    ((a0 and $002a2a2a) shl 9) or //-E-C -A-- -6-4 -2--|-e-c a--- ---- ----
  //    ((a0 and $2a000000) shr 23);  //---- ---- ---- ----|---- ---- -6-4 -2--
  //a2:=((a2 and $40404040) shr 5) or //---- --9- ---- --1-|---- --9- ---- --1-
  //    ((a2 and $00808080) shl 1) or //---- ---8 ---- ---0|---- ---8 ---- ----
  //    ((a2 and $80000000) shr 31);  //---- ---- ---- ----|---- ---- ---- ---0
    mov esi,ecx              //u
    and ecx,$2a2a2a2a        //v
    rol ecx,9                //u
    and esi,$15151515        //v
    shl esi,3                //u
    mov edi,ebx              //v
    rol ebx,1                //u
    and edi,$40404040        //v
    shr edi,5                //u
    and ebx,$01010101        //v
    or  ecx,esi              //u
    or  ebx,edi              //v
  //TInt(Result)[4]:= (a0 or a2) xor TInt(q)[4];
    or  ecx,ebx                            //u
    mov edi,dword ptr [eax+TLifeCel.q+4*4] //v
    xor edi,ecx                            //u
    mov ecx,dword ptr [eax+TLifeCel.p+5*4] //v
    mov [edx+4*4],edi                      //u

  //5555555555555555555555555555555555555555555555555
  //a0:= TInt(p)[5] and Mask0;
  //a2:= TInt(p)[6] and Mask2;
    and ecx,Mask0                          //v
    mov ebx,dword ptr [eax+TLifeCel.p+6*4] //u
    mov esi,[eax+TLifeCel.E]               //v
    and ebx,Mask2                          //u
  //if Assigned(E) then begin
    test esi,esi                            //v
    je  @@FiveNoS                           //u
  //  a0:= a0 or (TInt(E.p)[1] and Mask1);
  //  a2:= a2 or (TInt(E.p)[2] and Mask3);
    mov edi,dword ptr [esi+TLifeCel.p+1*4]  //u
    mov esi,dword ptr [esi+TLifeCel.p+2*4]  //v
    and edi,Mask1                           //u
    and esi,Mask3                           //v
    or  ecx,edi                             //u
    or  ebx,esi                             //v
  //end; {if}
@@FiveNoS:
  //a0:=((a0 and $15151515) shl 3) or //F-D- B--- 7-5- 3---|f-d- b--- 7-5- 3---
  //    ((a0 and $002a2a2a) shl 9) or //-E-C -A-- -6-4 -2--|-e-c a--- ---- ----
  //    ((a0 and $2a000000) shr 23);  //---- ---- ---- ----|---- ---- -6-4 -2--
  //a2:=((a2 and $40404040) shr 5) or //---- --9- ---- --1-|---- --9- ---- --1-
  //    ((a2 and $00808080) shl 1) or //---- ---8 ---- ---0|---- ---8 ---- ----
  //    ((a2 and $80000000) shr 31);  //---- ---- ---- ----|---- ---- ---- ---0
    mov esi,ecx              //u
    and ecx,$2a2a2a2a        //v
    rol ecx,9                //u
    and esi,$15151515        //v
    shl esi,3                //u
    mov edi,ebx              //v
    rol ebx,1                //u
    and edi,$40404040        //v
    shr edi,5                //u
    and ebx,$01010101        //v
    or  ecx,esi              //u
    or  ebx,edi              //v
  //TInt(Result)[5]:= (a0 or a2) xor TInt(q)[5];
    or  ecx,ebx                            //u
    mov edi,dword ptr [eax+TLifeCel.q+5*4] //v
    xor edi,ecx                            //u
    mov ecx,dword ptr [eax+TLifeCel.p+6*4] //v
    mov [edx+5*4],edi                      //u

  //6666666666666666666666666666666666666666666666666
  //a0:= TInt(p)[6] and Mask0;
  //a2:= TInt(p)[7] and Mask2;
    mov ebx,dword ptr [eax+TLifeCel.p+7*4] //v
    and ecx,Mask0                          //u
    mov esi,[eax+TLifeCel.E]               //v
    and ebx,Mask2                          //u
  //if Assigned(E) then begin
    test esi,esi               //v
    je  @@SixNoS               //u
  //  a0:= a0 or (TInt(E.p)[2] and Mask1);
  //  a2:= a2 or (TInt(E.p)[3] and Mask3);
    mov edi,dword ptr [esi+TLifeCel.p+2*4]  //u <<- always in u after jump.
    mov esi,dword ptr [esi+TLifeCel.p+3*4]  //v
    and edi,Mask1                           //u
    and esi,Mask3                           //v
    or  ecx,edi                             //u
    or  ebx,esi                             //v
  //end; {if}
@@SixNoS:
  //a0:=((a0 and $15151515) shl 3) or //F-D- B--- 7-5- 3---|f-d- b--- 7-5- 3---
  //    ((a0 and $002a2a2a) shl 9) or //-E-C -A-- -6-4 -2--|-e-c a--- ---- ----
  //    ((a0 and $2a000000) shr 23);  //---- ---- ---- ----|---- ---- -6-4 -2--
  //a2:=((a2 and $40404040) shr 5) or //---- --9- ---- --1-|---- --9- ---- --1-
  //    ((a2 and $00808080) shl 1) or //---- ---8 ---- ---0|---- ---8 ---- ----
  //    ((a2 and $80000000) shr 31);  //---- ---- ---- ----|---- ---- ---- ---0
    mov esi,ecx              //u
    and ecx,$2a2a2a2a        //v
    rol ecx,9                //u
    and esi,$15151515        //v
    shl esi,3                //u
    mov edi,ebx              //v
    rol ebx,1                //u
    and edi,$40404040        //v
    shr edi,5                //u
    and ebx,$01010101        //v
    or  ecx,esi              //u
    or  ebx,edi              //v
  //TInt(Result)[6]:= (a0 or a2) xor TInt(q)[6];
    or  ecx,ebx                            //u
    mov edi,dword ptr [eax+TLifeCel.q+6*4] //v
    xor edi,ecx                            //u
    mov ebx,dword ptr [eax+TLifeCel.p+7*4] //v
    mov [edx+6*4],edi                      //u

  //end; {asm}
  //7777777777777777777777777777777777777777777777777777777
  //a0:= TInt(p)[7] and Mask0;
    mov esi,[eax+TLifeCel.E]               //v
    and ebx,Mask0                          //u
  //if Assigned(E) then a0:= a0 or (TInt(E.p)[3] and Mask1);
    test esi,esi                           //v
    mov ecx,[eax+TLifeCel.S]               //u
    je  @@SevenNoE                         //v
    mov esi,dword ptr [esi+TLifeCel.p+3*4] //u
@@SevenNoE:
    and esi,Mask1                          //u
    mov edi,[eax+TLifeCel.SE]              //v
    or ebx,esi                             //u    a0 is ready now.
  //if Assigned(S) then a2:= TInt(S.p)[4] and Mask2
    test ecx,ecx                           //v
    je  @@SevenNoS                         //u
    mov ecx,dword ptr [ecx+TLifeCel.p+4*4] //u
    and ecx,Mask2                          //u
@@SevenNoS:
  //else a2:= 0;
  //if Assigned(SE) then a2:= a2 or (TInt(SE.p)[0] and Mask3);
    test edi,edi                           //v or u
    je  @@SevenNoSE                        //u or v
    mov edi,dword ptr [edi+TLifeCel.p+0*7] //u
    mov esi,ebx                            //v
@@SevenNoSE:
    and edi,Mask3                          //u
    mov esi,ebx                            //v <-double, but still 1 cycle saved
    or  ecx,edi                            //u  + I'm sure which pipe is up.

 //a0:=((a0 and $15151515) shl 3) or //F-D- B--- 7-5- 3---|f-d- b--- 7-5- 3---
 //     ((a0 and $002a2a2a) shl 9) or //-E-C -A-- -6-4 -2--|-e-c a--- ---- ----
 //     ((a0 and $2a000000) shr 23);  //---- ---- ---- ----|---- ---- -6-4 -2--
 // a2:=((a2 and $40404040) shr 5) or //---- --9- ---- --1-|---- --9- ---- --1-
 //     ((a2 and $00808080) shl 1) or //---- ---8 ---- ---0|---- ---8 ---- ----
 //     ((a2 and $80000000) shr 31);  //---- ---- ---- ----|---- ---- ---- ---0

    and ebx,$2a2a2a2a       //v
    rol ebx,9               //u
    and esi,$15151515       //v
    lea ebx,[ebx+esi*8]     //u

    mov edi,ecx             //v
    rol ecx,1               //u
    and edi,$40404040       //v
    shr edi,5               //u
    and ecx,$01010101       //v

    or  ecx,edi             //u
    pop edi                 //v
 // TInt(Result)[7]:= (a0 or a2) xor TInt(q)[7];
    or  ebx,ecx                            //u
    mov ecx,dword ptr [eax+TLifeCel.q+7*4] //v
    xor ebx,ecx                            //u
    pop esi                                //v
    mov [edx+7*4],ebx                      //u
    pop ebx                                //v
  end; {asm}

  //Uppercase chars go to lower word, unmarked go to high word.
  //pos:FEDC BA98 7654 3210|fedc ba98 7654 3210
  //a0:--6F 4D2B --E7 C5A3|---f -d-b --e7 c5a3  (high 642 to lower)
  //a1:---- ---- ---- ----|--6- 4-2- ---- ----  (lower 642 to high)
  //a2:09-- ---- 81-- ----|-9-- ---- 81-- ----  (high 0 to lower)
  //a3:---- ---- ---- ----|0--- ---- ---- ----  (low 0 to high)

end;  (**)


{please note that this routine is in every way the mirror image of Diff..P}
function TLifeCel.DifferenceWithQ: TSmall;  {version with full 32bit logic}
const
  Mask0 = $00010000;  //ok
  Mask1 = $03020303;  //ok
  Mask2 = $00540000;  //ok
  Mask3 = $fca8fcfc;  //ok
begin
  asm
  //77777777777777777777777777777777777777
  //a3:= TInt(q)[7] and Mask3;
  //a3:= a3 or (TInt(q)[3] and Mask2);
  //a1:= TInt(q)[6] and Mask1;
  //a1:= a1 or (TInt(q)[2] and Mask0);
    push ebx                                //u
    push esi                                //v
    push edi                                //u
    mov ecx,dword ptr [eax+TLifeCel.q+7*4]  //v
    mov ebx,dword ptr [eax+TLifeCel.q+3*4]  //u
    and ecx,Mask3                           //v
    and ebx,Mask2                           //u
    mov esi,dword ptr [eax+TLifeCel.q+2*4]  //v
    or ecx,ebx                              //u
    mov ebx,dword ptr [eax+TLifeCel.q+6*4]  //v
    and esi,Mask0                           //u
    and ebx,Mask1                           //v
    or ebx,esi                              //u  <<--no delay,b'caus new cycle
  //a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
  //     ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
  //     ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  //a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
  //     ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
  //     ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
    mov esi,ecx         //v
    and ecx,$54545454   //u
    and esi,$a8a8a8a8   //v
    ror ecx,9           //u  <<-- rcl can't run in v-pipe (does pair however).
    mov edi,ebx         //v
    ror esi,3           //u
    and ebx,$01010101   //v  <<-- ecx:= ecx or (esi shl 3)
    or  ecx,esi         //u
    and edi,$02020202   //v
    ror ebx,1           //u
    mov esi,dword ptr [eax+TLifeCel.p+7*4] //v
    shl edi,5           //u
    or  ebx,edi         //u

  //TInt(Result)[7]:= (a1 or a3) xor TInt(p)[7];
    mov edi,dword ptr [eax+TLifeCel.q+6*4] //v
    or  ecx,ebx                            //u
    mov ebx,dword ptr [eax+TLifeCel.q+2*4] //v
    xor esi,ecx                            //u
    and edi,Mask3                          //v
    mov [edx+7*4],esi                      //u

  //666666666666666666666666666666666666666
  //a3:= TInt(q)[6] and Mask3;
  //a3:= a3 or (TInt(q)[2] and Mask2);
  //a1:= TInt(q)[5] and Mask1;
  //a1:= a1 or (TInt(q)[1] and Mask0);
    and ebx,Mask2                          //v
    mov esi,dword ptr [eax+TLifeCel.q+1*4] //u
    or  edi,ebx                            //v
    mov ebx,dword ptr [eax+TLifeCel.q+5*4] //u
    and esi,Mask0                          //v
    and ebx,Mask1                          //u
    mov ecx,edi                            //v
    or  ebx,esi                            //u
  //a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
  //     ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
  //     ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  //a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
  //     ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
  //     ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
    and ecx,$54545454    //v
    ror ecx,9            //u
    and edi,$a8a8a8a8    //v
    shr edi,3            //u
    mov esi,ebx          //v
    or  ecx,edi          //u
    and ebx,$01010101    //v
    ror ebx,1            //u
    and esi,$02020202    //v
    shl esi,5            //u
    or  ebx,esi          //u
    mov edi,dword ptr [eax+TLifeCel.p+6*4] //v
  //TInt(Result)[6]:= (a1 or a3) xor TInt(p)[6];
    or  ecx,ebx                            //u
    mov ebx,dword ptr [eax+TLifeCel.q+1*4] //v
    xor edi,ecx                            //u
    mov ecx,dword ptr [eax+TLifeCel.q+5*4] //v
    mov [edx+6*4],edi                      //u

//555555555555555555555555555555555555555555
  //a3:= TInt(q)[5] and Mask3;
  //a3:= a3 or (TInt(q)[1] and Mask2);
  //a1:= TInt(q)[4] and Mask1;
  //a1:= a1 or (TInt(q)[0] and Mask0);
    and ecx,Mask3                          //v
    and ebx,Mask2                          //u
    mov esi,dword ptr [eax+TLifeCel.q+0*4] //v
    or  ecx,ebx                            //u
    mov ebx,dword ptr [eax+TLifeCel.q+4*4] //v
    and esi,Mask0                          //u
    and ebx,Mask1                          //v
    or  ebx,esi                            //u  <<-- new cycle no dep.
  //a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
  //     ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
  //     ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  //a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
  //     ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
  //     ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
    mov esi,ecx            //v
    shr esi,3              //u
    and ecx,$54545454      //v
    ror ecx,9              //u
    and esi,$15151515      //v
    mov edi,ebx            //u
    and edi,$02020202      //v
    shl edi,5              //u
    and ebx,$01010101      //v
    ror ebx,1              //u
    or  ecx,esi            //v
    or  ebx,edi            //u
    mov edi,dword ptr [eax+TLifeCel.p+5*4] //v
  //TInt(Result)[5]:= (a1 or a3) xor TInt(p)[5];
    or  ecx,ebx                            //u
    mov ebx,dword ptr [eax+TLifeCel.q+0*4] //v
    xor edi,ecx                            //u
    mov ecx,dword ptr [eax+TLifeCel.q+4*4] //v
    mov [edx+5*4],edi                      //u


  //44444444444444444444444444444444444444444
  //a3:= TInt(q)[4] and Mask3;
  //a3:= a3 or (TInt(q)[0] and Mask2);
    and ecx,Mask3              //v
    and ebx,Mask2              //u
    mov esi,[eax+TLifeCel.N]   //v
    or  ecx,ebx                //u
  //if Assigned(N) then begin
    test esi,esi               //v
    mov ebx,0                  //u <-- free 'cause je can only pair in v-pipe
    je  @@FourNoN              //v     + extra jump saved. mov saves flags.
  //a1:= TInt(N.q)[7] and Mask1;
  //a1:= a1 or (TInt(N.q)[3] and Mask0);
    mov ebx,dword ptr [esi+TLifeCel.q+7*4] //u
    mov esi,dword ptr [esi+TLifeCel.q+3*4] //v
    and ebx,Mask1                          //u
    and esi,Mask0                          //v
@@FourNoN:                                 // <- label's here 'cause or 0,0 = 0.
    or  ebx,esi                            //u <- now I always know which pipe
  //end {if}
  //else a1:= 0; {else}


  //a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
  //     ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
  //     ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  //a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
  //     ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
  //     ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
    mov esi,ecx          //v
    shr esi,3            //u
    and ecx,$54545454    //v
    ror ecx,9            //u
    and esi,$15151515    //v
    or  ecx,esi          //u

    mov esi,ebx          //v
    ror ebx,1            //u
    and esi,$02020202    //v
    shl esi,5            //u
    and ebx,$80808080    //v
    or  ebx,esi          //u
    mov edi,dword ptr [eax+TLifeCel.p+4*4] //v
  //TInt(Result)[4]:= (a1 or a3) xor TInt(p)[4];
    or  ecx,ebx                            //u
    mov ebx,dword ptr [eax+TLifeCel.q+2*4] //v
    xor edi,ecx                            //u
    mov ecx,dword ptr [eax+TLifeCel.q+3*4] //v
    mov [edx+4*4],edi                      //u

  //33333333333333333333333333333333333333333
  //a3:= TInt(q)[3] and Mask3;
  //a1:= TInt(q)[2] and Mask1;
    and ecx,Mask3              //v
    and ebx,Mask1              //u
  //if Assigned(W) then begin
    mov esi,[eax+TLifeCel.W]   //v
    test esi,esi               //u
    je  @@ThreeNoW             //v
  //a3:= a3 or (TInt(W.q)[7] and Mask2);
  //a1:= a1 or (TInt(W.q)[6] and Mask0);
    mov edi,dword ptr [esi+TLifeCel.q+7*4]  //u
    mov esi,dword ptr [esi+TLifeCel.q+6*4]  //v
    and edi,Mask2                           //u
    and esi,Mask0                           //v
    or  ecx,edi                             //u
    or  ebx,esi                             //v
  //end; {if}
@@ThreeNoW:
  //a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
  //     ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
  //     ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  //a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
  //     ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
  //     ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
    mov esi,ecx              //u
    and ecx,$54545454        //v
    ror ecx,9                //u
    and esi,$a8a8a8a8        //v
    shr esi,3                //u
    mov edi,ebx              //v
    ror ebx,1                //u
    and edi,$02020202        //v
    shl edi,5                //u
    and ebx,$80808080        //v
    or  ecx,esi              //u
    or  ebx,edi              //v
  //TInt(Result)[3]:= (a1 or a3) xor TInt(p)[3];
    or  ecx,ebx                            //u
    mov edi,dword ptr [eax+TLifeCel.p+3*4] //v
    xor edi,ecx                            //u
    mov ecx,dword ptr [eax+TLifeCel.q+2*4] //v
    mov [edx+3*4],edi                      //u

  //2222222222222222222222222222222222222222
  //a3:= TInt(q)[2] and Mask3;
  //a1:= TInt(q)[1] and Mask1;
    and ecx,Mask3                          //v
    mov ebx,dword ptr [eax+TLifeCel.q+1*4] //u
    mov esi,[eax+TLifeCel.W]               //v
    and ebx,Mask1                          //u
  //if Assigned(W) then begin
    test esi,esi                           //v
    je  @@TwoNoW                           //u
  //  a3:= a3 or (TInt(W.q)[6] and Mask2);
  //  a1:= a1 or (TInt(W.q)[5] and Mask0);
    mov edi,dword ptr [esi+TLifeCel.q+6*4]  //u
    mov esi,dword ptr [esi+TLifeCel.q+5*4]  //v
    and edi,Mask2                           //u
    and esi,Mask0                           //v
    or  ecx,edi                             //u
    or  ebx,esi                             //v
  //end; {if}
@@TwoNoW:
  //a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
  //     ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
  //     ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  //a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
  //     ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
  //     ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
    mov esi,ecx              //u
    and ecx,$54545454        //v
    ror ecx,9                //u
    and esi,$a8a8a8a8        //v
    shr esi,3                //u
    mov edi,ebx              //v
    ror ebx,1                //u
    and edi,$02020202        //v
    shl edi,5                //u
    and ebx,$80808080        //v
    or  ecx,esi              //u
    or  ebx,edi              //v
  //TInt(Result)[2]:= (a1 or a3) xor TInt(p)[2];
    or  ecx,ebx                            //u
    mov edi,dword ptr [eax+TLifeCel.p+2*4] //v
    xor edi,ecx                            //u
    mov ecx,dword ptr [eax+TLifeCel.q+1*4] //v
    mov [edx+2*4],edi                      //u

  //111111111111111111111111111111111111111111111111
  //a3:= TInt(q)[1] and Mask3;
  //a1:= TInt(q)[0] and Mask1;
    mov ebx,dword ptr [eax+TLifeCel.q+0*4] //v
    and ecx,Mask3                          //u
    mov esi,[eax+TLifeCel.W]               //v
    and ebx,Mask1                          //u
  //if Assigned(W) then begin
    test esi,esi               //v
    je  @@OneNoW               //u
  //  a3:= a3 or (TInt(W.q)[5] and Mask2);
  //  a1:= a1 or (TInt(W.q)[4] and Mask0);
    mov edi,dword ptr [esi+TLifeCel.q+5*4]  //u <<- always in u after jump.
    mov esi,dword ptr [esi+TLifeCel.q+4*4]  //v
    and edi,Mask2                           //u
    and esi,Mask0                           //v
    or  ecx,edi                             //u
    or  ebx,esi                             //v
  //end; {if}
@@OneNoW:
  //a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
  //     ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
  //     ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  //a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
  //     ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
  //     ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
    mov esi,ecx              //u
    and ecx,$54545454        //v
    ror ecx,9                //u
    and esi,$a8a8a8a8        //v
    shr esi,3                //u
    mov edi,ebx              //v
    ror ebx,1                //u
    and edi,$02020202        //v
    shl edi,5                //u
    and ebx,$80808080        //v
    or  ecx,esi              //u
    or  ebx,edi              //v
  //TInt(Result)[1]:= (a1 or a3) xor TInt(p)[1];
    or  ecx,ebx                            //u
    mov edi,dword ptr [eax+TLifeCel.p+1*4] //v
    xor edi,ecx                            //u
    mov ebx,dword ptr [eax+TLifeCel.q+0*4] //v
    mov [edx+1*4],edi                      //u

  //00000000000000000000000000000000000000000000000000
  //a3:= TInt(q)[0] and Mask3;
    mov esi,[eax+TLifeCel.W]               //v
    and ebx,Mask3                          //u
  //if Assigned(W) then a3:= a3 or (TInt(W.q)[4] and Mask2);
    test esi,esi                           //v
    mov ecx,[eax+TLifeCel.N]               //u
    je  @@NulNoW                         //v
    mov esi,dword ptr [esi+TLifeCel.q+4*4] //u
@@NulNoW:
    and esi,Mask2                          //u
    mov edi,[eax+TLifeCel.NW]              //v
    or ebx,esi                             //u    a0 is ready now.
  //if Assigned(N) then a1:= TInt(N.q)[3] and Mask1
    test ecx,ecx                           //v
    je  @@NulNoN                         //u
    mov ecx,dword ptr [ecx+TLifeCel.q+3*4] //u
    and ecx,Mask1                          //u
@@NulNoN:
  //else a1:= 0;
  //if Assigned(NW) then a1:= a1 or (TInt(NW.q)[7] and Mask0);
    test edi,edi                           //v or u
    je  @@NulNoNW                        //u or v
    mov edi,dword ptr [edi+TLifeCel.q+7*4] //u
    mov esi,ebx                            //v
@@NulNoNW:
    and edi,Mask0                          //u
    mov esi,ebx                            //v <-double, but still 1 cycle saved
    or  ecx,edi                            //u  + I'm sure which pipe is up.

  //a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
  //     ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
  //     ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  //a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
  //     ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
  //     ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
    and ebx,$54545454       //v
    ror ebx,9               //u
    and esi,$a8a8a8a8       //v
    ror esi,3               //u
    or  ebx,esi             //v
    mov edi,ecx             //v
    ror ecx,1               //u
    and edi,$02020202       //v
    shl edi,5               //u
    and ecx,$80808080       //v

    or  ecx,edi             //u
    pop edi                 //v
 //TInt(Result)[0]:= (a1 or a3) xor TInt(p)[0];
    or  ebx,ecx                            //u
    mov ecx,dword ptr [eax+TLifeCel.p+0*4] //v
    xor ebx,ecx                            //u
    pop esi                                //v
    mov [edx+0*4],ebx                      //u
    pop ebx                                //v
  end; {asm}
end;  (**)

  {This is a bit map. The current positions of the chars denote the positions of
   the bits before the shifting takes place. The hexnumbers denote the pos these
   bits should be shifted to, capitals should go to the high word (this is the
   LEFT word (damn Intel for using Little Endian). small letters go to the
   Low word, this is the Right word in the bitmap way back at the start of this
   unit}
  //chars in uppercase are to go to high word, chars in lower are to go to low word.
  //a0: ---- ---- ---- ---f|---- ---- ---- ----
  //a1: ---- --E7 ---- --6-|---- --e7 ---- --6F
  //a2: ---- ---- -d-b -9--|---- ---- ---- ----
  //a3: C5A3 81-- 4-2- 0---|c5a3 81-- 4D2B 09--

  //following bitmap has msb left(first) en lsb right(last)
  //msw is right on screen lsw is left on screen.



(*{please note that this routine is in every way the mirror image of Diff..Q}
function TLifeCel.DifferenceWithQ: TSmall;  {version with full 32bit logic}
const
  Mask0 = $00010000;  //ok
  Mask1 = $03020303;  //ok
  Mask2 = $00540000;  //ok
  Mask3 = $fca8fcfc;  //ok
var
  a1,a3: integer;
begin
  //77777777777777777777777777777777777777
  a3:= TInt(q)[7] and Mask3;
  a3:= a3 or (TInt(q)[3] and Mask2);
  a1:= TInt(q)[6] and Mask1;
  a1:= a1 or (TInt(q)[2] and Mask0);
  a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
       ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
       ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
       ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
       ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  TInt(Result)[7]:= (a1 or a3) xor TInt(p)[7];
  //666666666666666666666666666666666666666
  a3:= TInt(q)[6] and Mask3;
  a3:= a3 or (TInt(q)[2] and Mask2);
  a1:= TInt(q)[5] and Mask1;
  a1:= a1 or (TInt(q)[1] and Mask0);
  a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
       ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
       ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
       ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
       ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  TInt(Result)[6]:= (a1 or a3) xor TInt(p)[6];
  //555555555555555555555555555555555555555555
  a3:= TInt(q)[5] and Mask3;
  a3:= a3 or (TInt(q)[1] and Mask2);
  a1:= TInt(q)[4] and Mask1;
  a1:= a1 or (TInt(q)[0] and Mask0);
  a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
       ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
       ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
       ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
       ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  TInt(Result)[5]:= (a1 or a3) xor TInt(p)[5];

  //44444444444444444444444444444444444444444
  a3:= TInt(q)[4] and Mask3;
  a3:= a3 or (TInt(q)[0] and Mask2);
  if Assigned(N) then begin
    a1:= TInt(N.q)[7] and Mask1;
    a1:= a1 or (TInt(N.q)[3] and Mask0);
  end {if}
  else a1:= 0; {else}
  a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
       ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
       ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
       ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
       ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  TInt(Result)[4]:= (a1 or a3) xor TInt(p)[4];

  //33333333333333333333333333333333333333333
  a3:= TInt(q)[3] and Mask3;
  a1:= TInt(q)[2] and Mask1;
  if Assigned(W) then begin
    a3:= a3 or (TInt(W.q)[7] and Mask2);
    a1:= a1 or (TInt(W.q)[6] and Mask0);
  end; {if}
  a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
       ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
       ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
       ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
       ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  TInt(Result)[3]:= (a1 or a3) xor TInt(p)[3];

  //2222222222222222222222222222222222222222
  a3:= TInt(q)[2] and Mask3;
  a1:= TInt(q)[1] and Mask1;
  if Assigned(W) then begin
    a3:= a3 or (TInt(W.q)[6] and Mask2);
    a1:= a1 or (TInt(W.q)[5] and Mask0);
  end; {if}
  a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
       ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
       ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
       ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
       ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  TInt(Result)[2]:= (a1 or a3) xor TInt(p)[2];
  //111111111111111111111111111111111111111111111111
  a3:= TInt(q)[1] and Mask3;
  a1:= TInt(q)[0] and Mask1;
  if Assigned(W) then begin
    a3:= a3 or (TInt(W.q)[5] and Mask2);
    a1:= a1 or (TInt(W.q)[4] and Mask0);
  end; {if}
  a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
       ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
       ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
       ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
       ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  TInt(Result)[1]:= (a1 or a3) xor TInt(p)[1];

  //00000000000000000000000000000000000000000000000000
  a3:= TInt(q)[0] and Mask3;
  if Assigned(W) then a3:= a3 or (TInt(W.q)[4] and Mask2);
  if Assigned(N) then a1:= TInt(N.q)[3] and Mask1
  else a1:= 0;
  if Assigned(NW) then a1:= a1 or (TInt(NW.q)[7] and Mask0);
  a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
       ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
       ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
       ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
       ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  TInt(Result)[0]:= (a1 or a3) xor TInt(p)[0];
end; (**)

//commented out version of Display. keep this for bright speed-up ideas.
(*procedure TLifeCel.Display(XOffset, YOffset: Integer; DisplayQ: boolean);
var
  x1,y1: integer;
  x2,y2: integer;
  Diff: TSmall;
  OnOff: integer;
  Onn,Off: TSmall;
  i: integer;
  Color: integer;
  Clear:Boolean;
  XLeft,XTop,XRight,XBottom: integer;
begin
  x1:= x * 16;
  y1:= y * 16;
  Inc(x1,integer(DisplayQ));
  Inc(y1,integer(DisplayQ));
  x1:= x1 * CelSpace;
  y1:= y1 * CelSpace;
  Inc(x1,XOffset + DrawBound.Left);
  Inc(y1,yOffset + DrawBound.Top);

  x2:= x1;
  y2:= y1;

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  if DisplayQ then begin
    Diff:= DifferenceWithP;

    Tint(Onn)[0]:= TInt(q)[0] and TInt(Diff)[0];
    TInt(Off)[0]:= (not(TInt(q)[0])) and TInt(Diff)[0];
    Tint(Onn)[1]:= TInt(q)[1] and TInt(Diff)[1];
    TInt(Off)[1]:= (not(TInt(q)[1])) and TInt(Diff)[1];
    Tint(Onn)[2]:= TInt(q)[2] and TInt(Diff)[2];
    TInt(Off)[2]:= (not(TInt(q)[2])) and TInt(Diff)[2];
    Tint(Onn)[3]:= TInt(q)[3] and TInt(Diff)[3];
    TInt(Off)[3]:= (not(TInt(q)[3])) and TInt(Diff)[3];
    Tint(Onn)[4]:= TInt(q)[4] and TInt(Diff)[4];
    TInt(Off)[4]:= (not(TInt(q)[4])) and TInt(Diff)[4];
    Tint(Onn)[5]:= TInt(q)[5] and TInt(Diff)[5];
    TInt(Off)[5]:= (not(TInt(q)[5])) and TInt(Diff)[5];
    Tint(Onn)[6]:= TInt(q)[6] and TInt(Diff)[6];
    TInt(Off)[6]:= (not(TInt(q)[6])) and TInt(Diff)[6];
    Tint(Onn)[7]:= TInt(q)[7] and TInt(Diff)[7];
    TInt(Off)[7]:= (not(TInt(q)[7])) and TInt(Diff)[7];{}
  end {if}
  else begin
    Diff:= DifferenceWithQ;

    Tint(Onn)[0]:= TInt(p)[0] and TInt(Diff)[0];
    TInt(Off)[0]:= (not(TInt(p)[0])) and TInt(Diff)[0];
    Tint(Onn)[1]:= TInt(p)[1] and TInt(Diff)[1];
    TInt(Off)[1]:= (not(TInt(p)[1])) and TInt(Diff)[1];
    Tint(Onn)[2]:= TInt(p)[2] and TInt(Diff)[2];
    TInt(Off)[2]:= (not(TInt(p)[2])) and TInt(Diff)[2];
    Tint(Onn)[3]:= TInt(p)[3] and TInt(Diff)[3];
    TInt(Off)[3]:= (not(TInt(p)[3])) and TInt(Diff)[3];
    Tint(Onn)[4]:= TInt(p)[4] and TInt(Diff)[4];
    TInt(Off)[4]:= (not(TInt(p)[4])) and TInt(Diff)[4];
    Tint(Onn)[5]:= TInt(p)[5] and TInt(Diff)[5];
    TInt(Off)[5]:= (not(TInt(p)[5])) and TInt(Diff)[5];
    Tint(Onn)[6]:= TInt(p)[6] and TInt(Diff)[6];
    TInt(Off)[6]:= (not(TInt(p)[6])) and TInt(Diff)[6];
    Tint(Onn)[7]:= TInt(p)[7] and TInt(Diff)[7];
    TInt(Off)[7]:= (not(TInt(p)[7])) and TInt(Diff)[7];{}
  end; {else}
  {$ifdef time}
  MyTimer.StopNow;
  CumDiff:= CumDiff + MyTimer.TimePast.Totaal;
  MyTimer.StartNow;
  {$endif}

  for i:= 0 to 15 do begin
    //On pixels first;
    if (Onn[i] or Off[i]) <> 0 then begin
      case i of
        1: x2:= x1 + CelSpace4;
        2: begin x2:= x1; y2:= y1 + CelSpace4; end;
        3: begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace4; end;
        4: begin x2:= x1; y2:= y1 + CelSpace8; end;
        5: begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace8; end;
        6: begin x2:= x1; y2:= y1 + CelSpace12; end;
        7: begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace12; end;
        8: begin x2:= x1 + CelSpace8; y2:= y1; end;
        9: begin x2:= x1 + CelSpace12; y2:= y1; end;
        10: begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace4; end;
        11: begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace4; end;
        12: begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace8; end;
        13: begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace8; end;
        14: begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace12; end;
        15: begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace12; end;
      end; {case}

      OnOff:= Onn[i];
      Color:= ForeColor;
      for Clear:= false to true do begin
        if OnOff <> 0 then with DrawBound do begin
          if ((x2 > Left) and ((x2+CelSpace4) < Right)
          and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
          {do nothing because were are not near the border}
          else begin
            XLeft:= Left - x2;
            XTop:= Top - y2;
            XRight:= (x2 + CelSpace4) - Right;
            XBottom:= (y2 + CelSpace4) - Bottom;
            //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
            if XLeft > 0 then case ((XLeft -1) div CelSpace) of
              0: OnOff:= OnOff and $55ff;
              1: OnOff:= OnOff and $00ff;
              2: OnOff:= OnOff and $0055;
              else OnOff:= 0;
            end; {case}
            if XTop > 0 then case ((XTop -1) div CelSpace) of
              0: OnOff:= OnOff and $3f3f;
              1: OnOff:= OnOff and $0f0f;
              2: OnOff:= OnOff and $0303;
              else OnOff:= 0;
            end;
            if (XRight) > 0 then case ((XRight -1) div CelSpace) of
              0: OnOff:= OnOff and $ffaa;
              1: OnOff:= OnOff and $ff00;
              2: OnOff:= OnOff and $aa00;
              else OnOff:= 0;
            end; {case}
            if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
              0: OnOff:= OnOff and $fcfc;
              1: OnOff:= OnOff and $f0f0;
              2: OnOff:= OnOff and $c0c0;
              else OnOff:= 0;
            end;
          end; {else}
          MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
        end; {if}

        //Now off pixels
        OnOff:= Off[i];
        Color:= BackColor;
      end; {for wissen}
    end; {if}
  end; {for i}
  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayOff;
var
  x1,y1: integer;
  x2,y2: integer;
  Diff: TSmall;
  OnOff: integer;
  Off: TSmall;
  Color: TColor;
  XLeft,XTop,XRight,XBottom: integer;
  //Clear:Boolean;
begin
  //Special screen position calculation, so wrap around at the edge
  //of the universe works OK.
  x1:= smallint(coor.x - XorigDiv16);
  x1:= x1 * 16;
  Dec(x1,RestOfXOrig);
  x1:= x1 * CelSpace;
  Inc(x1,CenterX + StartPoint.x);

  y1:= smallint(coor.y - YOrigDiv16);
  y1:= y1 * 16;
  Dec(y1,RestOfYOrig);
  y1:= y1 * CelSpace;
  Inc(y1,CenterY + StartPoint.y);

  x2:= x1;
  y2:= y1;
  Color:= BackColor;

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  if DisplayQ then begin
    Diff:= DifferenceWithP;

    TInt(Off)[0]:= (not(TInt(q)[0])) and TInt(Diff)[0];
    TInt(Off)[1]:= (not(TInt(q)[1])) and TInt(Diff)[1];
    TInt(Off)[2]:= (not(TInt(q)[2])) and TInt(Diff)[2];
    TInt(Off)[3]:= (not(TInt(q)[3])) and TInt(Diff)[3];
    TInt(Off)[4]:= (not(TInt(q)[4])) and TInt(Diff)[4];
    TInt(Off)[5]:= (not(TInt(q)[5])) and TInt(Diff)[5];
    TInt(Off)[6]:= (not(TInt(q)[6])) and TInt(Diff)[6];
    TInt(Off)[7]:= (not(TInt(q)[7])) and TInt(Diff)[7];{}
  end {if}
  else begin
    Diff:= DifferenceWithQ;

    TInt(Off)[0]:= (not(TInt(p)[0])) and TInt(Diff)[0];
    TInt(Off)[1]:= (not(TInt(p)[1])) and TInt(Diff)[1];
    TInt(Off)[2]:= (not(TInt(p)[2])) and TInt(Diff)[2];
    TInt(Off)[3]:= (not(TInt(p)[3])) and TInt(Diff)[3];
    TInt(Off)[4]:= (not(TInt(p)[4])) and TInt(Diff)[4];
    TInt(Off)[5]:= (not(TInt(p)[5])) and TInt(Diff)[5];
    TInt(Off)[6]:= (not(TInt(p)[6])) and TInt(Diff)[6];
    TInt(Off)[7]:= (not(TInt(p)[7])) and TInt(Diff)[7];{}
  end; {else}
  {$ifdef time}
  MyTimer.StopNow;
  CumDiff:= CumDiff + MyTimer.TimePast.Totaal;
  MyTimer.StartNow;
  {$endif}
  if ((x2 > DrawBound.Left) and ((x2 + CelSpace16) < DrawBound.Right) and
     (y2 > DrawBound.Top) and ((y2 + CelSpace16) < DrawBound.Bottom)) then with MyDDSurface do begin
    if (Off[0] <> 0) then DisplayCelPart(x1,y1,Off[0],Color);
    if (Off[1] <> 0) then DisplayCelPart(x1+CelSpace4,y1,Off[1],Color);
    if (Off[2] <> 0) then DisplayCelPart(x1,y1+CelSpace4,Off[2],Color);
    if (Off[3] <> 0) then DisplayCelPart(x1+CelSpace4,y1+CelSpace4,Off[3],Color);
    if (Off[4] <> 0) then DisplayCelPart(x1,y1+CelSpace8,Off[4],Color);
    if (Off[5] <> 0) then DisplayCelPart(x1+CelSpace4,y1+CelSpace8,Off[5],Color);
    if (Off[6] <> 0) then DisplayCelPart(x1,y1+CelSpace12,Off[6],Color);
    if (Off[7] <> 0) then DisplayCelPart(x1+CelSpace4,y1+CelSpace12,Off[7],Color);
    if (Off[8] <> 0) then DisplayCelPart(x1+CelSpace8,y1,Off[8],Color);
    if (Off[9] <> 0) then DisplayCelPart(x1+CelSpace12,y1,Off[9],Color);
    if (Off[10] <> 0) then DisplayCelPart(x1+CelSpace8,y1+CelSpace4,Off[10],Color);
    if (Off[11] <> 0) then DisplayCelPart(x1+CelSpace12,y1+CelSpace4,Off[11],Color);
    if (Off[12] <> 0) then DisplayCelPart(x1+CelSpace8,y1+CelSpace8,Off[12],Color);
    if (Off[13] <> 0) then DisplayCelPart(x1+CelSpace12,y1+CelSpace8,Off[13],Color);
    if (Off[14] <> 0) then DisplayCelPart(x1+CelSpace8,y1+CelSpace12,Off[14],Color);
    if (Off[15] <> 0) then DisplayCelPart(x1+CelSpace12,y1+CelSpace12,Off[15],Color);
  end
  else begin
  //for i:= 0 to 15 do begin
  //Off pixels first;
  //00000000000000000000000000000000000000000000000000
    if (Off[0]) <> 0 then begin
      OnOff:= Off[0];
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[0];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //111111111111111111111111111111111111111111111111111111111
  if (Off[1]) <> 0 then begin
    x2:= x1 + CelSpace4;

    OnOff:= Off[1];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[1];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //22222222222222222222222222222222222222222222222222
  if (Off[2]) <> 0 then begin
    begin x2:= x1; y2:= y1 + CelSpace4; end;

    OnOff:= Off[2];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[2];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //3333333333333333333333333333333333333333333333333333
  if (Off[3]) <> 0 then begin
    begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace4; end;

    OnOff:= Off[3];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[3];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //44444444444444444444444444444444444444444444444444444444
  if (Off[4]) <> 0 then begin
    begin x2:= x1; y2:= y1 + CelSpace8; end;

    OnOff:= Off[4];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[4];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //55555555555555555555555555555555555555555555555555
  if (Off[5]) <> 0 then begin
    begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace8; end;

    OnOff:= Off[5];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[5];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //6666666666666666666666666666666666666666666666666
  if (Off[6]) <> 0 then begin
    begin x2:= x1; y2:= y1 + CelSpace12; end;

    OnOff:= Off[6];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[6];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //777777777777777777777777777777777777777777
  if (Off[7]) <> 0 then begin
    begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace12; end;

    OnOff:= Off[7];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[7];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //888888888888888888888888888888888888888888888888
  if (Off[8]) <> 0 then begin
    begin x2:= x1 + CelSpace8; y2:= y1; end;

    OnOff:= Off[8];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[8];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //999999999999999999999999999999999999999999999999999
  if (Off[9]) <> 0 then begin
    begin x2:= x1 + CelSpace12; y2:= y1; end;

    OnOff:= Off[9];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[9];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  if (Off[10]) <> 0 then begin
    begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace4; end;

    OnOff:= Off[10];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[10];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
  if (Off[11]) <> 0 then begin
    begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace4; end;

    OnOff:= Off[11];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[11];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //cccccccccccccccccccccccccccccccccccccccccccccc
  if (Off[12]) <> 0 then begin
    begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace8; end;

    OnOff:= Off[12];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[12];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //ddddddddddddddddddddddddddddddddddddddddddddddddd
  if (Off[13]) <> 0 then begin
    begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace8; end;

    OnOff:= Off[13];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[13];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
  if (Off[14]) <> 0 then begin
    begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace12; end;

    OnOff:= Off[14];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[14];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //fffffffffffffffffffffffffffffffffffffffffffffffff
  if (Off[15]) <> 0 then begin
    begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace12; end;

    OnOff:= Off[15];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[15];
      //Color:= BackColor;
    //end; {for wissen}
    end; {else}
  end; {if}
  //end; {for i}
  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  {}

procedure TLifeCel.DisplayOn;
var
  x1,y1: integer;
  x2,y2: integer;
  Diff: TSmall;
  OnOff: integer;
  Onn: TSmall;
  Color: integer;
  XLeft,XTop,XRight,XBottom: integer;
  //Clear:Boolean;
begin
  x1:= smallint(coor.x - XorigDiv16);
  x1:= x1 * 16;
  Dec(x1,RestOfXOrig);
  x1:= x1 * CelSpace;
  Inc(x1,CenterX + StartPoint.x);

  y1:= smallint(coor.y - YOrigDiv16);
  y1:= y1 * 16;
  Dec(y1,RestOfYOrig);
  y1:= y1 * CelSpace;
  Inc(y1,CenterY + StartPoint.y);

  x2:= x1;
  y2:= y1;

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  if DisplayQ then begin
    Diff:= DifferenceWithP;

    Tint(Onn)[0]:= TInt(q)[0] and TInt(Diff)[0];
    Tint(Onn)[1]:= TInt(q)[1] and TInt(Diff)[1];
    Tint(Onn)[2]:= TInt(q)[2] and TInt(Diff)[2];
    Tint(Onn)[3]:= TInt(q)[3] and TInt(Diff)[3];
    Tint(Onn)[4]:= TInt(q)[4] and TInt(Diff)[4];
    Tint(Onn)[5]:= TInt(q)[5] and TInt(Diff)[5];
    Tint(Onn)[6]:= TInt(q)[6] and TInt(Diff)[6];
    Tint(Onn)[7]:= TInt(q)[7] and TInt(Diff)[7];
  end {if}
  else begin
    Diff:= DifferenceWithQ;

    Tint(Onn)[0]:= TInt(p)[0] and TInt(Diff)[0];
    Tint(Onn)[1]:= TInt(p)[1] and TInt(Diff)[1];
    Tint(Onn)[2]:= TInt(p)[2] and TInt(Diff)[2];
    Tint(Onn)[3]:= TInt(p)[3] and TInt(Diff)[3];
    Tint(Onn)[4]:= TInt(p)[4] and TInt(Diff)[4];
    Tint(Onn)[5]:= TInt(p)[5] and TInt(Diff)[5];
    Tint(Onn)[6]:= TInt(p)[6] and TInt(Diff)[6];
    Tint(Onn)[7]:= TInt(p)[7] and TInt(Diff)[7];
  end; {else}
  {$ifdef time}
  MyTimer.StopNow;
  CumDiff:= CumDiff + MyTimer.TimePast.Totaal;
  MyTimer.StartNow;
  {$endif}

  Color:= ForeColor;

  if ((x2 > DrawBound.Left) and ((x2 + CelSpace16) < DrawBound.Right) and
     (y2 > DrawBound.Top) and ((y2 + CelSpace16) < DrawBound.Bottom)) then with MyDDSurface do begin
    if (Onn[0] <> 0) then DisplayCelPart(x1,y1,Onn[0],Color);
    if (Onn[1] <> 0) then DisplayCelPart(x1+CelSpace4,y1,Onn[1],Color);
    if (Onn[2] <> 0) then DisplayCelPart(x1,y1+CelSpace4,Onn[2],Color);
    if (Onn[3] <> 0) then DisplayCelPart(x1+CelSpace4,y1+CelSpace4,Onn[3],Color);
    if (Onn[4] <> 0) then DisplayCelPart(x1,y1+CelSpace8,Onn[4],Color);
    if (Onn[5] <> 0) then DisplayCelPart(x1+CelSpace4,y1+CelSpace8,Onn[5],Color);
    if (Onn[6] <> 0) then DisplayCelPart(x1,y1+CelSpace12,Onn[6],Color);
    if (Onn[7] <> 0) then DisplayCelPart(x1+CelSpace4,y1+CelSpace12,Onn[7],Color);
    if (Onn[8] <> 0) then DisplayCelPart(x1+CelSpace8,y1,Onn[8],Color);
    if (Onn[9] <> 0) then DisplayCelPart(x1+CelSpace12,y1,Onn[9],Color);
    if (Onn[10] <> 0) then DisplayCelPart(x1+CelSpace8,y1+CelSpace4,Onn[10],Color);
    if (Onn[11] <> 0) then DisplayCelPart(x1+CelSpace12,y1+CelSpace4,Onn[11],Color);
    if (Onn[12] <> 0) then DisplayCelPart(x1+CelSpace8,y1+CelSpace8,Onn[12],Color);
    if (Onn[13] <> 0) then DisplayCelPart(x1+CelSpace12,y1+CelSpace8,Onn[13],Color);
    if (Onn[14] <> 0) then DisplayCelPart(x1+CelSpace8,y1+CelSpace12,Onn[14],Color);
    if (Onn[15] <> 0) then DisplayCelPart(x1+CelSpace12,y1+CelSpace12,Onn[15],Color);
  end
  else begin
  //for i:= 0 to 15 do begin
  //On pixels first;
  //00000000000000000000000000000000000000000000000000
  if (Onn[0]) <> 0 then begin
    OnOff:= Onn[0];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[0];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //111111111111111111111111111111111111111111111111111111111
  if (Onn[1]) <> 0 then begin
    x2:= x1 + CelSpace4;

    OnOff:= Onn[1];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[1];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //22222222222222222222222222222222222222222222222222
  if (Onn[2]) <> 0 then begin
    begin x2:= x1; y2:= y1 + CelSpace4; end;

    OnOff:= Onn[2];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[2];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //3333333333333333333333333333333333333333333333333333
  if (Onn[3]) <> 0 then begin
    begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace4; end;

    OnOff:= Onn[3];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[3];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //44444444444444444444444444444444444444444444444444444444
  if (Onn[4]) <> 0 then begin
    begin x2:= x1; y2:= y1 + CelSpace8; end;

    OnOff:= Onn[4];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[4];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //55555555555555555555555555555555555555555555555555
  if (Onn[5]) <> 0 then begin
    begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace8; end;

    OnOff:= Onn[5];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[5];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //6666666666666666666666666666666666666666666666666
  if (Onn[6]) <> 0 then begin
    begin x2:= x1; y2:= y1 + CelSpace12; end;

    OnOff:= Onn[6];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[6];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //777777777777777777777777777777777777777777
  if (Onn[7]) <> 0 then begin
    begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace12; end;

    OnOff:= Onn[7];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[7];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //888888888888888888888888888888888888888888888888
  if (Onn[8]) <> 0 then begin
    begin x2:= x1 + CelSpace8; y2:= y1; end;

    OnOff:= Onn[8];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[8];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //999999999999999999999999999999999999999999999999999
  if (Onn[9]) <> 0 then begin
    begin x2:= x1 + CelSpace12; y2:= y1; end;

    OnOff:= Onn[9];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[9];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  if (Onn[10]) <> 0 then begin
    begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace4; end;

    OnOff:= Onn[10];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[10];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
  if (Onn[11]) <> 0 then begin
    begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace4; end;

    OnOff:= Onn[11];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[11];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //cccccccccccccccccccccccccccccccccccccccccccccc
  if (Onn[12]) <> 0 then begin
    begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace8; end;

    OnOff:= Onn[12];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[12];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //ddddddddddddddddddddddddddddddddddddddddddddddddd
  if (Onn[13]) <> 0 then begin
    begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace8; end;

    OnOff:= Onn[13];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[13];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
  if (Onn[14]) <> 0 then begin
    begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace12; end;

    OnOff:= Onn[14];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[14];
      //Color:= BackColor;
    //end; {for wissen}
  end; {if}
  //fffffffffffffffffffffffffffffffffffffffffffffffff
  if (Onn[15]) <> 0 then begin
    begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace12; end;

    OnOff:= Onn[15];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}  (**)
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      //OnOff:= Off[15];
      //Color:= BackColor;
    //end; {for wissen}
    end; {else}
  end; {if}
  //end; {for i}
  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  {}

procedure TLifeCel.DisplayAllOff;
var
  x1,y1: integer;
  x2,y2: integer;
  Off: integer;
  i: integer;
  Color: integer;
  XLeft, XTop, XRight, XBottom: integer;
  //Clear:Boolean;
begin
  x1:= smallint(coor.x - XorigDiv16);
  x1:= x1 * 16;
  Dec(x1,RestOfXOrig);
  x1:= x1 * CelSpace;
  Inc(x1,CenterX + StartPoint.x);

  y1:= smallint(coor.y - YOrigDiv16);
  y1:= y1 * 16;
  Dec(y1,RestOfYOrig);
  y1:= y1 * CelSpace;
  Inc(y1,CenterY + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  x2:= x1;
  y2:= y1;
  Color:= BackColor;

  for i:= 0 to 15 do begin
    if DisplayQ then begin
      Off:= not(q[i]);
    end {if}
    else begin
      Off:= not(p[i]);
    end; {else}

    //On pixels first;
    case i of
      1: x2:= x1 + CelSpace4;
      2: begin x2:= x1; y2:= y1 + CelSpace4; end;
      3: begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace4; end;
      4: begin x2:= x1; y2:= y1 + CelSpace8; end;
      5: begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace8; end;
      6: begin x2:= x1; y2:= y1 + CelSpace12; end;
      7: begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace12; end;
      8: begin x2:= x1 + CelSpace8; y2:= y1; end;
      9: begin x2:= x1 + CelSpace12; y2:= y1; end;
      10: begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace4; end;
      11: begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace4; end;
      12: begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace8; end;
      13: begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace8; end;
      14: begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace12; end;
      15: begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace12; end;
    end; {case}

    if Off <> 0 then with DrawBound do begin
      if ((x2 > Left) and ((x2+CelSpace4) < Right)
      and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
      {do nothing because were are not near the border}
      else begin
        XLeft:= Left - x2;
        XTop:= Top - y2;
        XRight:= (x2 + CelSpace4) - Right;
        XBottom:= (y2 + CelSpace4) - Bottom;
        //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
        if XLeft > 0 then case ((XLeft -1) div CelSpace) of
          0: Off:= Off and $55ff;
          1: Off:= Off and $00ff;
          2: Off:= Off and $0055;
          else Off:= 0;
        end; {case}
        if XTop > 0 then case ((XTop -1) div CelSpace) of
          0: Off:= Off and $3f3f;
          1: Off:= Off and $0f0f;
          2: Off:= Off and $0303;
          else Off:= 0;
        end;
        if (XRight) > 0 then case ((XRight -1) div CelSpace) of
          0: Off:= Off and $ffaa;
          1: Off:= Off and $ff00;
          2: Off:= Off and $aa00;
          else Off:= 0;
        end; {case}
        if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
          0: Off:= Off and $fcfc;
          1: Off:= Off and $f0f0;
          2: Off:= Off and $c0c0;
          else Off:= 0;
        end;
      end; {else}
      if (Off = -1) then begin
        //MessageBeep(0);
        MyDDSurface.DisplayBlackPart(x2,y2,Color)
      end
      else MyDDSurface.DisplayCelPart(x2,y2,Off,Color)
    end; {if}
  end; {for i}
  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  {}  (**)

procedure TLifeCel.DisplayAllOn;
var
  x1,y1: integer;
  x2,y2: integer;
  Onn: integer;
  i: integer;
  Color: integer;
  XLeft, XTop, XRight, XBottom: integer;
begin
  x1:= smallint(coor.x - XorigDiv16);
  x1:= x1 * 16;
  Dec(x1,RestOfXOrig);
  x1:= x1 * CelSpace;
  Inc(x1,CenterX + StartPoint.x);

  y1:= smallint(coor.y - YOrigDiv16);
  y1:= y1 * 16;
  Dec(y1,RestOfYOrig);
  y1:= y1 * CelSpace;
  Inc(y1,CenterY + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  x2:= x1;
  y2:= y1;
  Color:= ForeColor;
  for i:= 0 to 15 do begin
    if DisplayQ then begin
      Onn:= q[i];
    end {if}
    else begin
      Onn:= p[i];
    end; {else}

    //On pixels first;
    case i of
      1: x2:= x1 + CelSpace4;
      2: begin x2:= x1; y2:= y1 + CelSpace4; end;
      3: begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace4; end;
      4: begin x2:= x1; y2:= y1 + CelSpace8; end;
      5: begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace8; end;
      6: begin x2:= x1; y2:= y1 + CelSpace12; end;
      7: begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace12; end;
      8: begin x2:= x1 + CelSpace8; y2:= y1; end;
      9: begin x2:= x1 + CelSpace12; y2:= y1; end;
      10: begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace4; end;
      11: begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace4; end;
      12: begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace8; end;
      13: begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace8; end;
      14: begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace12; end;
      15: begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace12; end;
    end; {case}

    if Onn <> 0 then with DrawBound do begin
      if ((x2 > Left) and ((x2+CelSpace4) < Right)
      and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
      {do nothing because were are not near the border}
      else begin
        XLeft:= Left - x2;
        XTop:= Top - y2;
        XRight:= (x2 + CelSpace4) - Right;
        XBottom:= (y2 + CelSpace4) - Bottom;
        //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
        if XLeft > 0 then case ((XLeft -1) div CelSpace) of
          0: Onn:= Onn and $55ff;
          1: Onn:= Onn and $00ff;
          2: Onn:= Onn and $0055;
          else Onn:= 0;
        end; {case}
        if XTop > 0 then case ((XTop -1) div CelSpace) of
          0: Onn:= Onn and $3f3f;
          1: Onn:= Onn and $0f0f;
          2: Onn:= Onn and $0303;
          else Onn:= 0;
        end;
        if (XRight) > 0 then case ((XRight -1) div CelSpace) of
          0: Onn:= Onn and $ffaa;
          1: Onn:= Onn and $ff00;
          2: Onn:= Onn and $aa00;
          else Onn:= 0;
        end; {case}
        if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
          0: Onn:= Onn and $fcfc;
          1: Onn:= Onn and $f0f0;
          2: Onn:= Onn and $c0c0;
          else Onn:= 0;
        end;
      end; {else}
      if (Onn = -1) then begin
        //MessageBeep(0);
        MyDDSurface.DisplayBlackPart(x2,y2,Color)
      end
      else MyDDSurface.DisplayCelPart(x2,y2,Onn,Color)
    end; {if}

  end; {for i}
  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  {}  (**)


procedure TLifeCel.DisplayDrag(XOffset, YOffset: Integer; DisplayQ: boolean);
var
  x1,y1: integer;
  x2,y2: integer;
  OnOff: integer;
  Onn: integer;
  i: integer;
  Color: integer;
  XLeft, XTop, XRight, XBottom: integer;
begin
  x1:= coor.x * 16;
  y1:= coor.y * 16;
  Inc(x1,integer(DisplayQ));
  Inc(y1,integer(DisplayQ));
  x1:= x1 * CelSpace;
  y1:= y1 * CelSpace;
  Inc(x1,XOffset + StartPoint.x);
  Inc(y1,yOffset + StartPoint.y);


  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  x2:= x1;
  y2:= y1;
  for i:= 0 to 15 do begin
    if DisplayQ then begin
      Onn:= q[i];
    end {if}
    else begin
      Onn:= p[i];
    end; {else}

    //On pixels first;
    case i of
      1: x2:= x1 + CelSpace4;
      2: begin x2:= x1; y2:= y1 + CelSpace4; end;
      3: begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace4; end;
      4: begin x2:= x1; y2:= y1 + CelSpace8; end;
      5: begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace8; end;
      6: begin x2:= x1; y2:= y1 + CelSpace12; end;
      7: begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace12; end;
      8: begin x2:= x1 + CelSpace8; y2:= y1; end;
      9: begin x2:= x1 + CelSpace12; y2:= y1; end;
      10: begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace4; end;
      11: begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace4; end;
      12: begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace8; end;
      13: begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace8; end;
      14: begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace12; end;
      15: begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace12; end;
    end; {case}

    OnOff:= Onn;
    Color:= DragColor;
    if OnOff <> 0 then with DrawBound do begin
      if ((x2 > Left) and ((x2+CelSpace4) < Right)
      and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
      {do nothing because were are not near the border}
      else begin
        XLeft:= Left - x2;
        XTop:= Top - y2;
        XRight:= (x2 + CelSpace4) - Right;
        XBottom:= (y2 + CelSpace4) - Bottom;
        //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
        if XLeft > 0 then case ((XLeft -1) div CelSpace) of
          0: OnOff:= OnOff and $55ff;
          1: OnOff:= OnOff and $00ff;
          2: OnOff:= OnOff and $0055;
          else OnOff:= 0;
        end; {case}
        if XTop > 0 then case ((XTop -1) div CelSpace) of
          0: OnOff:= OnOff and $3f3f;
          1: OnOff:= OnOff and $0f0f;
          2: OnOff:= OnOff and $0303;
          else OnOff:= 0;
        end;
        if (XRight) > 0 then case ((XRight -1) div CelSpace) of
          0: OnOff:= OnOff and $ffaa;
          1: OnOff:= OnOff and $ff00;
          2: OnOff:= OnOff and $aa00;
          else OnOff:= 0;
        end; {case}
        if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
          0: OnOff:= OnOff and $fcfc;
          1: OnOff:= OnOff and $f0f0;
          2: OnOff:= OnOff and $c0c0;
          else OnOff:= 0;
        end;
      end; {else}
      if not(MyDDSurface.DirectDrawEnabled = DDFast) then
        MyDDSurface.Canvas.Brush.Color:= Color;
      MyDDSurface.DisplayCelPartXor(x2,y2,OnOff,Color)
    end; {if}
  end; {for i}
  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  {}  (**)


{$WARN COMBINING_SIGNED_UNSIGNED OFF}
function TLifeCel.ConvertQtoP: TSmall;  {version with full 32bit logic}
const
  Mask0 = $00010000;  //ok
  Mask1 = $03020303;  //ok
  Mask2 = $00540000;  //ok
  Mask3 = $fca8fcfc;  //ok
var
  a1,a3: integer;
begin
  //0:
  a3:= TInt(q)[0] and Mask3;
  if Assigned(W) then a3:= a3 or (TInt(W.q)[4] and Mask2);
  if Assigned(N) then a1:= TInt(N.q)[3] and Mask1
  else a1:= 0;
  if Assigned(NW) then a1:= a1 or (TInt(NW.q)[7] and Mask0);
  a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
       ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
       ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
       ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
       ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  TInt(Result)[0]:= (a1 or a3);

  //1:
  a3:= TInt(q)[1] and Mask3;
  a1:= TInt(q)[0] and Mask1;
  if Assigned(W) then begin
    a3:= a3 or (TInt(W.q)[5] and Mask2);
    a1:= a1 or (TInt(W.q)[4] and Mask0);
  end; {if}
  a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
       ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
       ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
       ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
       ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  TInt(Result)[1]:= (a1 or a3);

  //2:
  a3:= TInt(q)[2] and Mask3;
  a1:= TInt(q)[1] and Mask1;
  if Assigned(W) then begin
    a3:= a3 or (TInt(W.q)[6] and Mask2);
    a1:= a1 or (TInt(W.q)[5] and Mask0);
  end; {if}
  a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
       ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
       ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
       ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
       ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  TInt(Result)[2]:= (a1 or a3);

  //3:
  a3:= TInt(q)[3] and Mask3;
  a1:= TInt(q)[2] and Mask1;
  if Assigned(W) then begin
    a3:= a3 or (TInt(W.q)[7] and Mask2);
    a1:= a1 or (TInt(W.q)[6] and Mask0);
  end; {if}
  a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
       ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
       ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
       ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
       ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  TInt(Result)[3]:= (a1 or a3);

  //4:
  a3:= TInt(q)[4] and Mask3;
  a3:= a3 or (TInt(q)[0] and Mask2);
  if Assigned(N) then begin
    a1:= TInt(N.q)[7] and Mask1;
    a1:= a1 or (TInt(N.q)[3] and Mask0);
  end {if}
  else a1:= 0; {else}
  a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
       ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
       ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
       ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
       ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  TInt(Result)[4]:= (a1 or a3);

  //5:
  a3:= TInt(q)[5] and Mask3;
  a3:= a3 or (TInt(q)[1] and Mask2);
  a1:= TInt(q)[4] and Mask1;
  a1:= a1 or (TInt(q)[0] and Mask0);
  a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
       ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
       ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
       ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
       ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  TInt(Result)[5]:= (a1 or a3);

  //6:
  a3:= TInt(q)[6] and Mask3;
  a3:= a3 or (TInt(q)[2] and Mask2);
  a1:= TInt(q)[5] and Mask1;
  a1:= a1 or (TInt(q)[1] and Mask0);
  a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
       ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
       ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
       ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
       ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  TInt(Result)[6]:= (a1 or a3);

  //7:
  a3:= TInt(q)[7] and Mask3;
  a3:= a3 or (TInt(q)[3] and Mask2);
  a1:= TInt(q)[6] and Mask1;
  a1:= a1 or (TInt(q)[2] and Mask0);
  a1:= ((a1 and $02020202) shl 5) or //-E-- ---- -6-- ----|-e-- ---- -6-- ----
       ((a1 and $01010100) shr 1) or //---- ---- 7--- ----|f--- ---- 7--- ----
       ((a1 and $00000001) shl 31);  //F--- ---- ---- ----|---- ---- ---- ----
  a3:= ((a3 and $a8a8a8a8) shr 3) or //---c -a-8 ---4 -2-0|---c -a-8 ---4 -2-0
       ((a3 and $54545400) shr 9) or //---- ---- --5- 3-1-|--d- b-9- --5- 3-1-
       ((a3 and $00000054) shl 23);  //--D- B-9- ---- ----|---- ---- ---- ----
  TInt(Result)[7]:= (a1 or a3);

  {This is a bit map. The current positions of the chars denote the positions of
   the bits before the shifting takes place. The hexnumbers denote the pos these
   bits should be shifted to, capitals should go to the high word (this is the
   LEFT word (damn Intel for using Little Endian). small letters go to the
   Low word, this is the Right word in the bitmap way back at the start of this
   unit}
  //chars in uppercase are to go to high word, chars in lower are to go to low word.
  //a0: ---- ---- ---- ---f|---- ---- ---- ----
  //a1: ---- --E7 ---- --6-|---- --e7 ---- --6F
  //a2: ---- ---- -d-b -9--|---- ---- ---- ----
  //a3: C5A3 81-- 4-2- 0---|c5a3 81-- 4D2B 09--

  //following bitmap has msb left(first) en lsb right(last)
  //msw is right on screen lsw is left on screen.
end;
{$WARN COMBINING_SIGNED_UNSIGNED ON}


(**)

procedure TLifeCel.DisplayZoom_1Off;
var
  APart: array [0..3] of integer;
  i: integer;
  OnOff: integer;
  x1,y1,x2,y2: integer;
  XLeft, XTop, Xright, XBottom: integer;
  Color: integer;
  LikeP: TSmall;
  //Clear: boolean;
begin
  //Zoomfactor is -1; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  x1:= smallint(coor.x - XorigDiv16);
  x1:= x1 * 8;
  Dec(x1,RestOfXOrig);
  Inc(x1,CenterX + StartPoint.x);

  y1:= smallint(coor.y - YOrigDiv16);
  y1:= y1 * 8;
  Dec(y1,RestOfYOrig);
  Inc(y1,CenterY + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  x2:= x1;
  y2:= y1;
  if DisplayQ then LikeP:= convertQtoP;
  Color:= BackColor;
  for i:= 0 to 3 do begin
    case i of
      1: y2:= y1 + CelSpace4;
      2: begin x2:= x1 + CelSpace4; y2:= y1; end;
      3: begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace4; end;
    end; {case}
    case DisplayQ of
      true: begin
        APart[i]:= 0;
        OnOff:= TInt(LikeP)[i*2+0];
        if (OnOff and $0000F000) <> 0 then APart[i]:= APart[i] or $8000;
        if (OnOff and $00000f00) <> 0 then APart[i]:= APart[i] or $2000;
        if (OnOff and $000000f0) <> 0 then APart[i]:= APart[i] or $4000;
        if (OnOff and $0000000f) <> 0 then APart[i]:= APart[i] or $1000;
        if (OnOff and $f0000000) <> 0 then APart[i]:= APart[i] or $0080;
        if (OnOff and $0f000000) <> 0 then APart[i]:= APart[i] or $0020;
        if (OnOff and $00f00000) <> 0 then APart[i]:= APart[i] or $0040;
        if (OnOff and $000f0000) <> 0 then APart[i]:= APart[i] or $0010;
        OnOff:= TInt(LikeP)[i*2+1];
        if (OnOff and $0000F000) <> 0 then APart[i]:= APart[i] or $0800;
        if (OnOff and $00000f00) <> 0 then APart[i]:= APart[i] or $0200;
        if (OnOff and $000000f0) <> 0 then APart[i]:= APart[i] or $0400;
        if (OnOff and $0000000f) <> 0 then APart[i]:= APart[i] or $0100;
        if (OnOff and $f0000000) <> 0 then APart[i]:= APart[i] or $0008;
        if (OnOff and $0f000000) <> 0 then APart[i]:= APart[i] or $0002;
        if (OnOff and $00f00000) <> 0 then APart[i]:= APart[i] or $0004;
        if (OnOff and $000f0000) <> 0 then APart[i]:= APart[i] or $0001;
      end; {true}
      else begin
        APart[i]:= 0;
        OnOff:= TInt(p)[i*2+0];
        if (OnOff and $0000F000) <> 0 then APart[i]:= APart[i] or $8000;
        if (OnOff and $00000f00) <> 0 then APart[i]:= APart[i] or $2000;
        if (OnOff and $000000f0) <> 0 then APart[i]:= APart[i] or $4000;
        if (OnOff and $0000000f) <> 0 then APart[i]:= APart[i] or $1000;
        if (OnOff and $f0000000) <> 0 then APart[i]:= APart[i] or $0080;
        if (OnOff and $0f000000) <> 0 then APart[i]:= APart[i] or $0020;
        if (OnOff and $00f00000) <> 0 then APart[i]:= APart[i] or $0040;
        if (OnOff and $000f0000) <> 0 then APart[i]:= APart[i] or $0010;
        OnOff:= TInt(p)[i*2+1];
        if (OnOff and $0000F000) <> 0 then APart[i]:= APart[i] or $0800;
        if (OnOff and $00000f00) <> 0 then APart[i]:= APart[i] or $0200;
        if (OnOff and $000000f0) <> 0 then APart[i]:= APart[i] or $0400;
        if (OnOff and $0000000f) <> 0 then APart[i]:= APart[i] or $0100;
        if (OnOff and $f0000000) <> 0 then APart[i]:= APart[i] or $0008;
        if (OnOff and $0f000000) <> 0 then APart[i]:= APart[i] or $0002;
        if (OnOff and $00f00000) <> 0 then APart[i]:= APart[i] or $0004;
        if (OnOff and $000f0000) <> 0 then APart[i]:= APart[i] or $0001;
      end; {false:}
    end; {case}
    OnOff:= not(APart[i]);
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
      end; {with}
      MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color);
      //Color:= BackColor;
      //OnOff:= not(OnOff);
    //end; {for Clear}
  end; {for i}
  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_1On;
var
  APart: array [0..3] of integer;
  i: integer;
  OnOff: integer;
  x1,y1,x2,y2: integer;
  XLeft, XTop, Xright, XBottom: integer;
  Color: integer;
  LikeP: TSmall;
  //Clear: boolean;
begin
  //Zoomfactor is -1; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  x1:= smallint(coor.x - XorigDiv16);
  x1:= x1 * 8;
  Dec(x1,RestOfXOrig);
  Inc(x1,CenterX + StartPoint.x);

  y1:= smallint(coor.y - YOrigDiv16);
  y1:= y1 * 8;
  Dec(y1,RestOfYOrig);
  Inc(y1,CenterY + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  x2:= x1;
  y2:= y1;
  if DisplayQ then LikeP:= convertQtoP;
  Color:= ForeColor;
  for i:= 0 to 3 do begin
    case i of
      1: y2:= y1 + CelSpace4;
      2: begin x2:= x1 + CelSpace4; y2:= y1; end;
      3: begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace4; end;
    end; {case}
    case DisplayQ of
      true: begin
        APart[i]:= 0;
        OnOff:= TInt(LikeP)[i*2+0];
        if (OnOff and $0000F000) <> 0 then APart[i]:= APart[i] or $8000;
        if (OnOff and $00000f00) <> 0 then APart[i]:= APart[i] or $2000;
        if (OnOff and $000000f0) <> 0 then APart[i]:= APart[i] or $4000;
        if (OnOff and $0000000f) <> 0 then APart[i]:= APart[i] or $1000;
        if (OnOff and $f0000000) <> 0 then APart[i]:= APart[i] or $0080;
        if (OnOff and $0f000000) <> 0 then APart[i]:= APart[i] or $0020;
        if (OnOff and $00f00000) <> 0 then APart[i]:= APart[i] or $0040;
        if (OnOff and $000f0000) <> 0 then APart[i]:= APart[i] or $0010;
        OnOff:= TInt(LikeP)[i*2+1];
        if (OnOff and $0000F000) <> 0 then APart[i]:= APart[i] or $0800;
        if (OnOff and $00000f00) <> 0 then APart[i]:= APart[i] or $0200;
        if (OnOff and $000000f0) <> 0 then APart[i]:= APart[i] or $0400;
        if (OnOff and $0000000f) <> 0 then APart[i]:= APart[i] or $0100;
        if (OnOff and $f0000000) <> 0 then APart[i]:= APart[i] or $0008;
        if (OnOff and $0f000000) <> 0 then APart[i]:= APart[i] or $0002;
        if (OnOff and $00f00000) <> 0 then APart[i]:= APart[i] or $0004;
        if (OnOff and $000f0000) <> 0 then APart[i]:= APart[i] or $0001;
      end; {true}
      else begin
        APart[i]:= 0;
        OnOff:= TInt(p)[i*2+0];
        if (OnOff and $0000F000) <> 0 then APart[i]:= APart[i] or $8000;
        if (OnOff and $00000f00) <> 0 then APart[i]:= APart[i] or $2000;
        if (OnOff and $000000f0) <> 0 then APart[i]:= APart[i] or $4000;
        if (OnOff and $0000000f) <> 0 then APart[i]:= APart[i] or $1000;
        if (OnOff and $f0000000) <> 0 then APart[i]:= APart[i] or $0080;
        if (OnOff and $0f000000) <> 0 then APart[i]:= APart[i] or $0020;
        if (OnOff and $00f00000) <> 0 then APart[i]:= APart[i] or $0040;
        if (OnOff and $000f0000) <> 0 then APart[i]:= APart[i] or $0010;
        OnOff:= TInt(p)[i*2+1];
        if (OnOff and $0000F000) <> 0 then APart[i]:= APart[i] or $0800;
        if (OnOff and $00000f00) <> 0 then APart[i]:= APart[i] or $0200;
        if (OnOff and $000000f0) <> 0 then APart[i]:= APart[i] or $0400;
        if (OnOff and $0000000f) <> 0 then APart[i]:= APart[i] or $0100;
        if (OnOff and $f0000000) <> 0 then APart[i]:= APart[i] or $0008;
        if (OnOff and $0f000000) <> 0 then APart[i]:= APart[i] or $0002;
        if (OnOff and $00f00000) <> 0 then APart[i]:= APart[i] or $0004;
        if (OnOff and $000f0000) <> 0 then APart[i]:= APart[i] or $0001;
      end; {false:}
    end; {case}
    OnOff:= APart[i];
    //Color:= ForeColor;
    //for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
      end; {with}
      MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color);
      //Color:= BackColor;
      //OnOff:= not(OnOff);
    //end; {for Clear}
  end; {for i}
  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)


procedure TLifeCel.DisplayZoom_2Off;
var
  OnOff: integer;
  x1,y1,x2,y2: integer;
  XLeft, XTop, Xright, XBottom: integer;
  Color: integer;
  LikeP: TSmall;
  //Clear: boolean;
begin
  //Zoomfactor is -2; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  x1:= smallint(coor.x - XorigDiv16);
  x1:= x1 * 4;
  Dec(x1,RestOfXOrig);
  Inc(x1,CenterX + StartPoint.x);

  y1:= smallint(coor.y - YOrigDiv16);
  y1:= y1 * 4;
  Dec(y1,RestOfYOrig);
  Inc(y1,CenterY + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  x2:= x1;
  y2:= y1;
  OnOff:= 0;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      if (TInt(LikeP)[0] and $0000ffff) <> 0 then OnOff:= OnOff or $8000;
      if (TInt(LikeP)[0] and $ffff0000) <> 0 then OnOff:= OnOff or $4000;
      if (TInt(LikeP)[1] and $0000ffff) <> 0 then OnOff:= OnOff or $2000;
      if (TInt(LikeP)[1] and $ffff0000) <> 0 then OnOff:= OnOff or $1000;
      if (TInt(LikeP)[2] and $0000ffff) <> 0 then OnOff:= OnOff or $0800;
      if (TInt(LikeP)[2] and $ffff0000) <> 0 then OnOff:= OnOff or $0400;
      if (TInt(LikeP)[3] and $0000ffff) <> 0 then OnOff:= OnOff or $0200;
      if (TInt(LikeP)[3] and $ffff0000) <> 0 then OnOff:= OnOff or $0100;
      if (TInt(LikeP)[4] and $0000ffff) <> 0 then OnOff:= OnOff or $0080;
      if (TInt(LikeP)[4] and $ffff0000) <> 0 then OnOff:= OnOff or $0040;
      if (TInt(LikeP)[5] and $0000ffff) <> 0 then OnOff:= OnOff or $0020;
      if (TInt(LikeP)[5] and $ffff0000) <> 0 then OnOff:= OnOff or $0010;
      if (TInt(LikeP)[6] and $0000ffff) <> 0 then OnOff:= OnOff or $0008;
      if (TInt(LikeP)[6] and $ffff0000) <> 0 then OnOff:= OnOff or $0004;
      if (TInt(LikeP)[7] and $0000ffff) <> 0 then OnOff:= OnOff or $0002;
      if (TInt(LikeP)[7] and $ffff0000) <> 0 then OnOff:= OnOff or $0001;
    end; {true}
    else begin
      if (TInt(p)[0] and $0000ffff) <> 0 then OnOff:= OnOff or $8000;
      if (TInt(p)[0] and $ffff0000) <> 0 then OnOff:= OnOff or $4000;
      if (TInt(p)[1] and $0000ffff) <> 0 then OnOff:= OnOff or $2000;
      if (TInt(p)[1] and $ffff0000) <> 0 then OnOff:= OnOff or $1000;
      if (TInt(p)[2] and $0000ffff) <> 0 then OnOff:= OnOff or $0800;
      if (TInt(p)[2] and $ffff0000) <> 0 then OnOff:= OnOff or $0400;
      if (TInt(p)[3] and $0000ffff) <> 0 then OnOff:= OnOff or $0200;
      if (TInt(p)[3] and $ffff0000) <> 0 then OnOff:= OnOff or $0100;
      if (TInt(p)[4] and $0000ffff) <> 0 then OnOff:= OnOff or $0080;
      if (TInt(p)[4] and $ffff0000) <> 0 then OnOff:= OnOff or $0040;
      if (TInt(p)[5] and $0000ffff) <> 0 then OnOff:= OnOff or $0020;
      if (TInt(p)[5] and $ffff0000) <> 0 then OnOff:= OnOff or $0010;
      if (TInt(p)[6] and $0000ffff) <> 0 then OnOff:= OnOff or $0008;
      if (TInt(p)[6] and $ffff0000) <> 0 then OnOff:= OnOff or $0004;
      if (TInt(p)[7] and $0000ffff) <> 0 then OnOff:= OnOff or $0002;
      if (TInt(p)[7] and $ffff0000) <> 0 then OnOff:= OnOff or $0001;
    end; {false:}
  end; {case}
  Color:= BackColor;
  OnOff:= not(OnOff);
  //for Clear:= false to true do begin
    if OnOff <> 0 then with DrawBound do begin
      if ((x2 > Left) and ((x2+CelSpace4) < Right)
      and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
      {do nothing because were are not near the border}
      else begin
        XLeft:= Left - x2;
        XTop:= Top - y2;
        XRight:= (x2 + CelSpace4) - Right;
        XBottom:= (y2 + CelSpace4) - Bottom;
        //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
        if XLeft > 0 then case ((XLeft -1) div CelSpace) of
          0: OnOff:= OnOff and $55ff;
          1: OnOff:= OnOff and $00ff;
          2: OnOff:= OnOff and $0055;
          else OnOff:= 0;
        end; {case}
        if XTop > 0 then case ((XTop -1) div CelSpace) of
          0: OnOff:= OnOff and $3f3f;
          1: OnOff:= OnOff and $0f0f;
          2: OnOff:= OnOff and $0303;
          else OnOff:= 0;
        end;
        if (XRight) > 0 then case ((XRight -1) div CelSpace) of
          0: OnOff:= OnOff and $ffaa;
          1: OnOff:= OnOff and $ff00;
          2: OnOff:= OnOff and $aa00;
          else OnOff:= 0;
        end; {case}
        if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
          0: OnOff:= OnOff and $fcfc;
          1: OnOff:= OnOff and $f0f0;
          2: OnOff:= OnOff and $c0c0;
          else OnOff:= 0;
        end;
      end; {else}
    end; {with}
    MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color);
    //Color:= BackColor;
    //OnOff:= not(OnOff);
  //end; {for Clear}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_2On;
var
  OnOff: integer;
  x1,y1,x2,y2: integer;
  XLeft, XTop, Xright, XBottom: integer;
  Color: integer;
  LikeP: TSmall;
  //Clear: boolean;
begin
  //Zoomfactor is -2; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  x1:= smallint(coor.x - XorigDiv16);
  x1:= x1 * 4;
  Dec(x1,RestOfXOrig);
  Inc(x1,CenterX + StartPoint.x);

  y1:= smallint(coor.y - YOrigDiv16);
  y1:= y1 * 4;
  Dec(y1,RestOfYOrig);
  Inc(y1,CenterY + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  x2:= x1;
  y2:= y1;
  OnOff:= 0;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      if (TInt(LikeP)[0] and $0000ffff) <> 0 then OnOff:= OnOff or $8000;
      if (TInt(LikeP)[0] and $ffff0000) <> 0 then OnOff:= OnOff or $4000;
      if (TInt(LikeP)[1] and $0000ffff) <> 0 then OnOff:= OnOff or $2000;
      if (TInt(LikeP)[1] and $ffff0000) <> 0 then OnOff:= OnOff or $1000;
      if (TInt(LikeP)[2] and $0000ffff) <> 0 then OnOff:= OnOff or $0800;
      if (TInt(LikeP)[2] and $ffff0000) <> 0 then OnOff:= OnOff or $0400;
      if (TInt(LikeP)[3] and $0000ffff) <> 0 then OnOff:= OnOff or $0200;
      if (TInt(LikeP)[3] and $ffff0000) <> 0 then OnOff:= OnOff or $0100;
      if (TInt(LikeP)[4] and $0000ffff) <> 0 then OnOff:= OnOff or $0080;
      if (TInt(LikeP)[4] and $ffff0000) <> 0 then OnOff:= OnOff or $0040;
      if (TInt(LikeP)[5] and $0000ffff) <> 0 then OnOff:= OnOff or $0020;
      if (TInt(LikeP)[5] and $ffff0000) <> 0 then OnOff:= OnOff or $0010;
      if (TInt(LikeP)[6] and $0000ffff) <> 0 then OnOff:= OnOff or $0008;
      if (TInt(LikeP)[6] and $ffff0000) <> 0 then OnOff:= OnOff or $0004;
      if (TInt(LikeP)[7] and $0000ffff) <> 0 then OnOff:= OnOff or $0002;
      if (TInt(LikeP)[7] and $ffff0000) <> 0 then OnOff:= OnOff or $0001;
    end; {true}
    else begin
      if (TInt(p)[0] and $0000ffff) <> 0 then OnOff:= OnOff or $8000;
      if (TInt(p)[0] and $ffff0000) <> 0 then OnOff:= OnOff or $4000;
      if (TInt(p)[1] and $0000ffff) <> 0 then OnOff:= OnOff or $2000;
      if (TInt(p)[1] and $ffff0000) <> 0 then OnOff:= OnOff or $1000;
      if (TInt(p)[2] and $0000ffff) <> 0 then OnOff:= OnOff or $0800;
      if (TInt(p)[2] and $ffff0000) <> 0 then OnOff:= OnOff or $0400;
      if (TInt(p)[3] and $0000ffff) <> 0 then OnOff:= OnOff or $0200;
      if (TInt(p)[3] and $ffff0000) <> 0 then OnOff:= OnOff or $0100;
      if (TInt(p)[4] and $0000ffff) <> 0 then OnOff:= OnOff or $0080;
      if (TInt(p)[4] and $ffff0000) <> 0 then OnOff:= OnOff or $0040;
      if (TInt(p)[5] and $0000ffff) <> 0 then OnOff:= OnOff or $0020;
      if (TInt(p)[5] and $ffff0000) <> 0 then OnOff:= OnOff or $0010;
      if (TInt(p)[6] and $0000ffff) <> 0 then OnOff:= OnOff or $0008;
      if (TInt(p)[6] and $ffff0000) <> 0 then OnOff:= OnOff or $0004;
      if (TInt(p)[7] and $0000ffff) <> 0 then OnOff:= OnOff or $0002;
      if (TInt(p)[7] and $ffff0000) <> 0 then OnOff:= OnOff or $0001;
    end; {false:}
  end; {case}
  Color:= ForeColor;
  //for Clear:= false to true do begin
    if OnOff <> 0 then with DrawBound do begin
      if ((x2 > Left) and ((x2+CelSpace4) < Right)
      and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
      {do nothing because were are not near the border}
      else begin
        XLeft:= Left - x2;
        XTop:= Top - y2;
        XRight:= (x2 + CelSpace4) - Right;
        XBottom:= (y2 + CelSpace4) - Bottom;
        //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
        if XLeft > 0 then case ((XLeft -1) div CelSpace) of
          0: OnOff:= OnOff and $55ff;
          1: OnOff:= OnOff and $00ff;
          2: OnOff:= OnOff and $0055;
          else OnOff:= 0;
        end; {case}
        if XTop > 0 then case ((XTop -1) div CelSpace) of
          0: OnOff:= OnOff and $3f3f;
          1: OnOff:= OnOff and $0f0f;
          2: OnOff:= OnOff and $0303;
          else OnOff:= 0;
        end;
        if (XRight) > 0 then case ((XRight -1) div CelSpace) of
          0: OnOff:= OnOff and $ffaa;
          1: OnOff:= OnOff and $ff00;
          2: OnOff:= OnOff and $aa00;
          else OnOff:= 0;
        end; {case}
        if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
          0: OnOff:= OnOff and $fcfc;
          1: OnOff:= OnOff and $f0f0;
          2: OnOff:= OnOff and $c0c0;
          else OnOff:= 0;
        end;
      end; {else}
    end; {with}
    MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color);
    //Color:= BackColor;
    //OnOff:= not(OnOff);
  //end; {for Clear}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)


procedure TLifeCel.DisplayZoom_3Off;
var
  OnOff: integer;
  x1,y1,x2,y2: integer;
  XLeft, XTop, Xright, XBottom: integer;
  Color: integer;
  LikeP: TSmall;
  //Clear: boolean;
begin
  //Zoomfactor is -3; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  x1:= smallint(coor.x - XorigDiv16);
  x1:= x1 * 2;
  Dec(x1,RestOfXOrig);
  Inc(x1,CenterX + StartPoint.x);

  y1:= smallint(coor.y - YOrigDiv16);
  y1:= y1 * 2;
  Dec(y1,RestOfYOrig);
  Inc(y1,CenterY + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  x2:= x1;
  y2:= y1;
  OnOff:= 0;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      if (TInt(LikeP)[0] or TInt(LikeP)[1]) <> 0 then OnOff:= OnOff or $8000;
      if (TInt(LikeP)[2] or TInt(LikeP)[3]) <> 0 then OnOff:= OnOff or $2000;
      if (TInt(LikeP)[4] or TInt(LikeP)[5]) <> 0 then OnOff:= OnOff or $4000;
      if (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0 then OnOff:= OnOff or $1000;
    end; {true}
    else begin
      if (TInt(p)[0] or TInt(p)[1]) <> 0 then OnOff:= OnOff or $8000;
      if (TInt(p)[2] or TInt(p)[3]) <> 0 then OnOff:= OnOff or $2000;
      if (TInt(p)[4] or TInt(p)[5]) <> 0 then OnOff:= OnOff or $4000;
      if (TInt(p)[6] or TInt(p)[7]) <> 0 then OnOff:= OnOff or $1000;
    end; {false:}
  end; {case}
  OnOff:= (not(OnOff) and $f000);
  Color:= BackColor;
  //for Clear:= false to true do begin
    if OnOff <> 0 then with DrawBound do begin
      if ((x2 > Left) and ((x2+CelSpace2) < Right)
      and (y2 > Top) and ((y2+CelSpace2) < Bottom)) then
      {do nothing because were are not near the border}
      else begin
        XLeft:= Left - x2;
        XTop:= Top - y2;
        XRight:= (x2 + CelSpace2) - Right;
        XBottom:= (y2 + CelSpace2) - Bottom;
        //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
        if XLeft > 0 then case ((XLeft -1) ) of
          0: OnOff:= OnOff and $55ff;
          else OnOff:= 0;
        end; {case}
        if XTop > 0 then case ((XTop -1) ) of
          0: OnOff:= OnOff and $3f3f;
          else OnOff:= 0;
        end;
        if (XRight) > 0 then case ((XRight -1) ) of
          0: OnOff:= OnOff and $aa00;
          else OnOff:= 0;
        end; {case}
        if (XBottom) > 0 then case ((XBottom -1) ) of
          0: OnOff:= OnOff and $c0c0;
          else OnOff:= 0;
        end;
      end; {else}
    end; {with}
    MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color);
    //Color:= BackColor;
    //OnOff:= (not(OnOff) and $f000);
  //end; {for Clear}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_3On;
var
  OnOff: integer;
  x1,y1,x2,y2: integer;
  XLeft, XTop, Xright, XBottom: integer;
  Color: integer;
  LikeP: TSmall;
  //Clear: boolean;
begin
  //Zoomfactor is -3; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  x1:= smallint(coor.x - XorigDiv16);
  x1:= x1 * 2;
  Dec(x1,RestOfXOrig);
  Inc(x1,CenterX + StartPoint.x);

  y1:= smallint(coor.y - YOrigDiv16);
  y1:= y1 * 2;
  Dec(y1,RestOfYOrig);
  Inc(y1,CenterY + StartPoint.y);
  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  x2:= x1;
  y2:= y1;
  OnOff:= 0;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      if (TInt(LikeP)[0] or TInt(LikeP)[1]) <> 0 then OnOff:= OnOff or $8000;
      if (TInt(LikeP)[2] or TInt(LikeP)[3]) <> 0 then OnOff:= OnOff or $2000;
      if (TInt(LikeP)[4] or TInt(LikeP)[5]) <> 0 then OnOff:= OnOff or $4000;
      if (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0 then OnOff:= OnOff or $1000;
    end; {true}
    else begin
      if (TInt(p)[0] or TInt(p)[1]) <> 0 then OnOff:= OnOff or $8000;
      if (TInt(p)[2] or TInt(p)[3]) <> 0 then OnOff:= OnOff or $2000;
      if (TInt(p)[4] or TInt(p)[5]) <> 0 then OnOff:= OnOff or $4000;
      if (TInt(p)[6] or TInt(p)[7]) <> 0 then OnOff:= OnOff or $1000;
    end; {false:}
  end; {case}
  Color:= ForeColor;
  //for Clear:= false to true do begin
    if OnOff <> 0 then with DrawBound do begin
      if ((x2 > Left) and ((x2+CelSpace2) < Right)
      and (y2 > Top) and ((y2+CelSpace2) < Bottom)) then
      {do nothing because were are not near the border}
      else begin
        XLeft:= Left - x2;
        XTop:= Top - y2;
        XRight:= (x2 + CelSpace2) - Right;
        XBottom:= (y2 + CelSpace2) - Bottom;
        //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
        if XLeft > 0 then case ((XLeft -1) ) of
          0: OnOff:= OnOff and $55ff;
          else OnOff:= 0;
        end; {case}
        if XTop > 0 then case ((XTop -1) ) of
          0: OnOff:= OnOff and $3f3f;
          else OnOff:= 0;
        end;
        if (XRight) > 0 then case ((XRight -1) ) of
          0: OnOff:= OnOff and $aa00;
          else OnOff:= 0;
        end; {case}
        if (XBottom) > 0 then case ((XBottom -1) ) of
          0: OnOff:= OnOff and $c0c0;
          else OnOff:= 0;
        end;
      end; {else}
    end; {with}
    MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color);
    //Color:= BackColor;
    //OnOff:= (not(OnOff) and $f000);
  //end; {for Clear}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)


procedure TLifeCel.DisplayZoom_4Off;
var
  OnOff: integer;
  x2,y2: integer;
  LikeP: TSmall;
  Color: integer;
begin
  //Zoomfactor is -4; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  //x1:= x * 1;
  //y1:= y * 1;
  x2:= smallint(coor.x - XorigDiv16);
  Inc(x2,CenterX + StartPoint.x);

  y2:= smallint(coor.y - YOrigDiv16);
  Inc(y2,CenterY + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  OnOff:= $8000;
  Color:= BackColor;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      if (TInt(LikeP)[0] or TInt(LikeP)[1]) or (TInt(LikeP)[2] or TInt(LikeP)[3]) or
         (TInt(LikeP)[4] or TInt(LikeP)[5]) or (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0
      then exit; //**** Exit if we have an ON cell
    end; {true}
    else begin
      if (TInt(p)[0] or TInt(p)[1]) or (TInt(p)[2] or TInt(p)[3]) or
         (TInt(p)[4] or TInt(p)[5]) or (TInt(p)[6] or TInt(p)[7]) <> 0
      then exit; //**** Exit if we have an ON cell
    end; {false:}
  end; {case}
  with DrawBound do begin
    if ((x2 > Left) and ((x2+CelSpace) < Right)
    and (y2 > Top) and ((y2+CelSpace) < Bottom)) then begin
      MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color);
    end; {if}
  end; {with}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_4On;
var
  OnOff: integer;
  x2,y2: integer;
  LikeP: TSmall;
  Color: integer;
  OK: Boolean;
begin
  //Zoomfactor is -4; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  //x1:= x * 1;
  //y1:= y * 1;
  x2:= smallint(coor.x - XorigDiv16);
  Inc(x2,CenterX + StartPoint.x);

  y2:= smallint(coor.y - YOrigDiv16);
  Inc(y2,CenterY + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  OnOff:= $8000;
  Color:= ForeColor;
  OK:= false;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      if (TInt(LikeP)[0] or TInt(LikeP)[1]) or (TInt(LikeP)[2] or TInt(LikeP)[3]) or
         (TInt(LikeP)[4] or TInt(LikeP)[5]) or (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0
      then OK:= true;
    end; {true}
    else begin
      if (TInt(p)[0] or TInt(p)[1]) or (TInt(p)[2] or TInt(p)[3]) or
         (TInt(p)[4] or TInt(p)[5]) or (TInt(p)[6] or TInt(p)[7]) <> 0
      then OK:= true;
    end; {false:}
  end; {case}
  if OK then with DrawBound do begin
    if ((x2 > Left) and ((x2+CelSpace) < Right)
    and (y2 > Top) and ((y2+CelSpace) < Bottom)) then begin
      MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color);
    end; {if}
  end; {with}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)


procedure TLifeCel.DisplayZoom_5Off;
var
  OnOff: integer;
  x2,y2: integer;
  LikeP: TSmall;
  IsOn: boolean;
begin
  //Zoomfactor is -4; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  //x1:= x div 2;
  //y1:= y div 2;
  //x2:= x1 + XOffset + StartPoint.x;
  //y2:= y1 + YOffset + StartPoint.y;

  x2:= smallint(coor.x - XorigDiv16) div 2;
  //Dec(x1,RestOfXOrig);
  Inc(x2,CenterX + StartPoint.x);

  y2:= smallint(coor.y - YOrigDiv16) div 2;
  //Dec(y1,RestOfYOrig);
  Inc(y2,CenterY + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  OnOff:= $8000;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      IsOn:= (TInt(LikeP)[0] or TInt(LikeP)[1]) or (TInt(LikeP)[2] or TInt(LikeP)[3]) or
         (TInt(LikeP)[4] or TInt(LikeP)[5]) or (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0;
    end; {true}
    else begin
      IsOn:= (TInt(p)[0] or TInt(p)[1]) or (TInt(p)[2] or TInt(p)[3]) or
         (TInt(p)[4] or TInt(p)[5]) or (TInt(p)[6] or TInt(p)[7]) <> 0;
    end; {false:}
  end; {case}
  if Not(IsOn) then with DrawBound do begin
    if ((x2 > Left) and ((x2+CelSpace) < Right)
    and (y2 > Top) and ((y2+CelSpace) < Bottom)) then begin
      MyDDSurface.DisplayCelPart(x2,y2,OnOff,BackColor);
    end; {if}
  end; {with}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_5On;
var
  OnOff: integer;
  x2,y2: integer;
  LikeP: TSmall;
  IsOn: boolean;
begin
  //Zoomfactor is -4; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  //x1:= x div 2;
  //y1:= y div 2;
  //x2:= x1 + XOffset + StartPoint.x;
  //y2:= y1 + YOffset + StartPoint.y;

  x2:= smallint(coor.x - XorigDiv16) div 2;
  //Dec(x1,RestOfXOrig);
  Inc(x2,CenterX + StartPoint.x);

  y2:= smallint(coor.y - YOrigDiv16) div 2;
  //Dec(y1,RestOfYOrig);
  Inc(y2,CenterY + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  OnOff:= $8000;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      IsOn:= (TInt(LikeP)[0] or TInt(LikeP)[1]) or (TInt(LikeP)[2] or TInt(LikeP)[3]) or
         (TInt(LikeP)[4] or TInt(LikeP)[5]) or (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0;
    end; {true}
    else begin
      IsOn:= (TInt(p)[0] or TInt(p)[1]) or (TInt(p)[2] or TInt(p)[3]) or
         (TInt(p)[4] or TInt(p)[5]) or (TInt(p)[6] or TInt(p)[7]) <> 0;
    end; {false:}
  end; {case}
  if IsOn then with DrawBound do begin
    if ((x2 > Left) and ((x2+CelSpace) < Right)
    and (y2 > Top) and ((y2+CelSpace) < Bottom)) then begin
      MyDDSurface.DisplayCelPart(x2,y2,OnOff,ForeColor);
    end; {if}
  end; {with}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_6Off;
var
  OnOff: integer;
  x2,y2: integer;
  LikeP: TSmall;
  IsOn: boolean;
begin
  //Zoomfactor is -4; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  //x1:= x div 2;
  //y1:= y div 2;
  //x2:= x1 + XOffset + StartPoint.x;
  //y2:= y1 + YOffset + StartPoint.y;

  x2:= smallint(coor.x - XorigDiv16) div 4;
  //Dec(x1,RestOfXOrig);
  Inc(x2,CenterX + StartPoint.x);

  y2:= smallint(coor.y - YOrigDiv16) div 4;
  //Dec(y1,RestOfYOrig);
  Inc(y2,CenterY + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  OnOff:= $8000;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      IsOn:= (TInt(LikeP)[0] or TInt(LikeP)[1]) or (TInt(LikeP)[2] or TInt(LikeP)[3]) or
         (TInt(LikeP)[4] or TInt(LikeP)[5]) or (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0;
    end; {true}
    else begin
      IsOn:= (TInt(p)[0] or TInt(p)[1]) or (TInt(p)[2] or TInt(p)[3]) or
         (TInt(p)[4] or TInt(p)[5]) or (TInt(p)[6] or TInt(p)[7]) <> 0;
    end; {false:}
  end; {case}
  if Not(IsOn) then with DrawBound do begin
    if ((x2 > Left) and ((x2+CelSpace) < Right)
    and (y2 > Top) and ((y2+CelSpace) < Bottom)) then begin
      MyDDSurface.DisplayCelPart(x2,y2,OnOff,BackColor);
    end; {if}
  end; {with}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_6On;
var
  OnOff: integer;
  x2,y2: integer;
  LikeP: TSmall;
  IsOn: boolean;
begin
  //Zoomfactor is -6; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  //x1:= x div 2;
  //y1:= y div 2;
  //x2:= x1 + XOffset + StartPoint.x;
  //y2:= y1 + YOffset + StartPoint.y;

  x2:= smallint(coor.x - XorigDiv16) div 4;
  //Dec(x1,RestOfXOrig);
  Inc(x2,CenterX + StartPoint.x);

  y2:= smallint(coor.y - YOrigDiv16) div 4;
  //Dec(y1,RestOfYOrig);
  Inc(y2,CenterY + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  OnOff:= $8000;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      IsOn:= (TInt(LikeP)[0] or TInt(LikeP)[1]) or (TInt(LikeP)[2] or TInt(LikeP)[3]) or
         (TInt(LikeP)[4] or TInt(LikeP)[5]) or (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0;
    end; {true}
    else begin
      IsOn:= (TInt(p)[0] or TInt(p)[1]) or (TInt(p)[2] or TInt(p)[3]) or
         (TInt(p)[4] or TInt(p)[5]) or (TInt(p)[6] or TInt(p)[7]) <> 0;
    end; {false:}
  end; {case}
  if IsOn then with DrawBound do begin
    if ((x2 > Left) and ((x2+CelSpace) < Right)
    and (y2 > Top) and ((y2+CelSpace) < Bottom)) then begin
      MyDDSurface.DisplayCelPart(x2,y2,OnOff,ForeColor);
    end; {if}
  end; {with}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_7Off;
var
  OnOff: integer;
  x2,y2: integer;
  LikeP: TSmall;
  IsOn: boolean;
begin
  //Zoomfactor is -7; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  //x1:= x div 2;
  //y1:= y div 2;
  //x2:= x1 + XOffset + StartPoint.x;
  //y2:= y1 + YOffset + StartPoint.y;

  x2:= smallint(coor.x - XorigDiv16) div 8;
  //Dec(x1,RestOfXOrig);
  Inc(x2,CenterX + StartPoint.x);

  y2:= smallint(coor.y - YOrigDiv16) div 8;
  //Dec(y1,RestOfYOrig);
  Inc(y2,CenterY + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  OnOff:= $8000;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      IsOn:= (TInt(LikeP)[0] or TInt(LikeP)[1]) or (TInt(LikeP)[2] or TInt(LikeP)[3]) or
         (TInt(LikeP)[4] or TInt(LikeP)[5]) or (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0;
    end; {true}
    else begin
      IsOn:= (TInt(p)[0] or TInt(p)[1]) or (TInt(p)[2] or TInt(p)[3]) or
         (TInt(p)[4] or TInt(p)[5]) or (TInt(p)[6] or TInt(p)[7]) <> 0;
    end; {false:}
  end; {case}
  if Not(IsOn) then with DrawBound do begin
    if ((x2 > Left) and ((x2+CelSpace) < Right)
    and (y2 > Top) and ((y2+CelSpace) < Bottom)) then begin
      MyDDSurface.DisplayCelPart(x2,y2,OnOff,BackColor);
    end; {if}
  end; {with}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_7On;
var
  OnOff: integer;
  x2,y2: integer;
  LikeP: TSmall;
  IsOn: boolean;
begin
  //Zoomfactor is -7; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  //x1:= x div 2;
  //y1:= y div 2;
  //x2:= x1 + XOffset + StartPoint.x;
  //y2:= y1 + YOffset + StartPoint.y;

  x2:= smallint(coor.x - XorigDiv16) div 8;
  //Dec(x1,RestOfXOrig);
  Inc(x2,CenterX + StartPoint.x);

  y2:= smallint(coor.y - YOrigDiv16) div 8;
  //Dec(y1,RestOfYOrig);
  Inc(y2,CenterY + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  OnOff:= $8000;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      IsOn:= (TInt(LikeP)[0] or TInt(LikeP)[1]) or (TInt(LikeP)[2] or TInt(LikeP)[3]) or
         (TInt(LikeP)[4] or TInt(LikeP)[5]) or (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0;
    end; {true}
    else begin
      IsOn:= (TInt(p)[0] or TInt(p)[1]) or (TInt(p)[2] or TInt(p)[3]) or
         (TInt(p)[4] or TInt(p)[5]) or (TInt(p)[6] or TInt(p)[7]) <> 0;
    end; {false:}
  end; {case}
  if IsOn then with DrawBound do begin
    if ((x2 > Left) and ((x2+CelSpace) < Right)
    and (y2 > Top) and ((y2+CelSpace) < Bottom)) then begin
      MyDDSurface.DisplayCelPart(x2,y2,OnOff,ForeColor);
    end; {if}
  end; {with}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_8Off;
var
  OnOff: integer;
  x2,y2: integer;
  LikeP: TSmall;
  IsOn: boolean;
begin
  //Zoomfactor is -8; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  //x1:= x div 2;
  //y1:= y div 2;
  //x2:= x1 + XOffset + StartPoint.x;
  //y2:= y1 + YOffset + StartPoint.y;

  x2:= smallint(coor.x - XorigDiv16) div 16;
  //Dec(x1,RestOfXOrig);
  Inc(x2,CenterX + StartPoint.x);

  y2:= smallint(coor.y - YOrigDiv16) div 16;
  //Dec(y1,RestOfYOrig);
  Inc(y2,CenterY + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  OnOff:= $8000;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      IsOn:= (TInt(LikeP)[0] or TInt(LikeP)[1]) or (TInt(LikeP)[2] or TInt(LikeP)[3]) or
         (TInt(LikeP)[4] or TInt(LikeP)[5]) or (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0;
    end; {true}
    else begin
      IsOn:= (TInt(p)[0] or TInt(p)[1]) or (TInt(p)[2] or TInt(p)[3]) or
         (TInt(p)[4] or TInt(p)[5]) or (TInt(p)[6] or TInt(p)[7]) <> 0;
    end; {false:}
  end; {case}
  if Not(IsOn) then with DrawBound do begin
    if ((x2 > Left) and ((x2+CelSpace) < Right)
    and (y2 > Top) and ((y2+CelSpace) < Bottom)) then begin
      MyDDSurface.DisplayCelPart(x2,y2,OnOff,BackColor);
    end; {if}
  end; {with}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_8On;
var
  OnOff: integer;
  x2,y2: integer;
  LikeP: TSmall;
  IsOn: boolean;
begin
  //Zoomfactor is -8; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  //x1:= x div 2;
  //y1:= y div 2;
  //x2:= x1 + XOffset + StartPoint.x;
  //y2:= y1 + YOffset + StartPoint.y;

  x2:= smallint(coor.x - XorigDiv16) div 16;
  //Dec(x1,RestOfXOrig);
  Inc(x2,CenterX + StartPoint.x);

  y2:= smallint(coor.y - YOrigDiv16) div 16;
  //Dec(y1,RestOfYOrig);
  Inc(y2,CenterY + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  OnOff:= $8000;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      IsOn:= (TInt(LikeP)[0] or TInt(LikeP)[1]) or (TInt(LikeP)[2] or TInt(LikeP)[3]) or
         (TInt(LikeP)[4] or TInt(LikeP)[5]) or (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0;
    end; {true}
    else begin
      IsOn:= (TInt(p)[0] or TInt(p)[1]) or (TInt(p)[2] or TInt(p)[3]) or
         (TInt(p)[4] or TInt(p)[5]) or (TInt(p)[6] or TInt(p)[7]) <> 0;
    end; {false:}
  end; {case}
  if IsOn then with DrawBound do begin
    if ((x2 > Left) and ((x2+CelSpace) < Right)
    and (y2 > Top) and ((y2+CelSpace) < Bottom)) then begin
      MyDDSurface.DisplayCelPart(x2,y2,OnOff,ForeColor);
    end; {if}
  end; {with}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)


procedure TLifeCel.DisplayZoom_1Drag(XOffset,YOffset: integer; DisplayQ: boolean);
var
  APart: array [0..3] of integer;
  i: integer;
  OnOff: integer;
  x1,y1,x2,y2: integer;
  XLeft, XTop, Xright, XBottom: integer;
  LikeP: TSmall;
begin
  //Zoomfactor is -1; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  x1:= coor.x * 8;
  y1:= coor.y * 8;
  Inc(x1,XOffset + StartPoint.x);
  Inc(y1,YOffset + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  x2:= x1;
  y2:= y1;
  if DisplayQ then LikeP:= convertQtoP;
  for i:= 0 to 3 do begin
    case i of
      1: y2:= y1 + CelSpace4;
      2: begin x2:= x1 + CelSpace4; y2:= y1; end;
      3: begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace4; end;
    end; {case}
    case DisplayQ of
      true: begin
        APart[i]:= 0;
        OnOff:= TInt(LikeP)[i*2+0];
        if (OnOff and $0000F000) <> 0 then APart[i]:= APart[i] or $8000;
        if (OnOff and $00000f00) <> 0 then APart[i]:= APart[i] or $2000;
        if (OnOff and $000000f0) <> 0 then APart[i]:= APart[i] or $4000;
        if (OnOff and $0000000f) <> 0 then APart[i]:= APart[i] or $1000;
        if (OnOff and $f0000000) <> 0 then APart[i]:= APart[i] or $0080;
        if (OnOff and $0f000000) <> 0 then APart[i]:= APart[i] or $0020;
        if (OnOff and $00f00000) <> 0 then APart[i]:= APart[i] or $0040;
        if (OnOff and $000f0000) <> 0 then APart[i]:= APart[i] or $0010;
        OnOff:= TInt(LikeP)[i*2+1];
        if (OnOff and $0000F000) <> 0 then APart[i]:= APart[i] or $0800;
        if (OnOff and $00000f00) <> 0 then APart[i]:= APart[i] or $0200;
        if (OnOff and $000000f0) <> 0 then APart[i]:= APart[i] or $0400;
        if (OnOff and $0000000f) <> 0 then APart[i]:= APart[i] or $0100;
        if (OnOff and $f0000000) <> 0 then APart[i]:= APart[i] or $0008;
        if (OnOff and $0f000000) <> 0 then APart[i]:= APart[i] or $0002;
        if (OnOff and $00f00000) <> 0 then APart[i]:= APart[i] or $0004;
        if (OnOff and $000f0000) <> 0 then APart[i]:= APart[i] or $0001;
      end; {true}
      else begin
        APart[i]:= 0;
        OnOff:= TInt(p)[i*2+0];
        if (OnOff and $0000F000) <> 0 then APart[i]:= APart[i] or $8000;
        if (OnOff and $00000f00) <> 0 then APart[i]:= APart[i] or $2000;
        if (OnOff and $000000f0) <> 0 then APart[i]:= APart[i] or $4000;
        if (OnOff and $0000000f) <> 0 then APart[i]:= APart[i] or $1000;
        if (OnOff and $f0000000) <> 0 then APart[i]:= APart[i] or $0080;
        if (OnOff and $0f000000) <> 0 then APart[i]:= APart[i] or $0020;
        if (OnOff and $00f00000) <> 0 then APart[i]:= APart[i] or $0040;
        if (OnOff and $000f0000) <> 0 then APart[i]:= APart[i] or $0010;
        OnOff:= TInt(p)[i*2+1];
        if (OnOff and $0000F000) <> 0 then APart[i]:= APart[i] or $0800;
        if (OnOff and $00000f00) <> 0 then APart[i]:= APart[i] or $0200;
        if (OnOff and $000000f0) <> 0 then APart[i]:= APart[i] or $0400;
        if (OnOff and $0000000f) <> 0 then APart[i]:= APart[i] or $0100;
        if (OnOff and $f0000000) <> 0 then APart[i]:= APart[i] or $0008;
        if (OnOff and $0f000000) <> 0 then APart[i]:= APart[i] or $0002;
        if (OnOff and $00f00000) <> 0 then APart[i]:= APart[i] or $0004;
        if (OnOff and $000f0000) <> 0 then APart[i]:= APart[i] or $0001;
      end; {false:}
    end; {case}
    OnOff:= APart[i];
    if OnOff <> 0 then with DrawBound do begin
      if ((x2 > Left) and ((x2+CelSpace4) < Right)
      and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
      {do nothing because were are not near the border}
      else begin
        XLeft:= Left - x2;
        XTop:= Top - y2;
        XRight:= (x2 + CelSpace4) - Right;
        XBottom:= (y2 + CelSpace4) - Bottom;
        //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
        if XLeft > 0 then case ((XLeft -1) div CelSpace) of
          0: OnOff:= OnOff and $55ff;
          1: OnOff:= OnOff and $00ff;
          2: OnOff:= OnOff and $0055;
          else OnOff:= 0;
        end; {case}
        if XTop > 0 then case ((XTop -1) div CelSpace) of
          0: OnOff:= OnOff and $3f3f;
          1: OnOff:= OnOff and $0f0f;
          2: OnOff:= OnOff and $0303;
          else OnOff:= 0;
        end;
        if (XRight) > 0 then case ((XRight -1) div CelSpace) of
          0: OnOff:= OnOff and $ffaa;
          1: OnOff:= OnOff and $ff00;
          2: OnOff:= OnOff and $aa00;
          else OnOff:= 0;
        end; {case}
        if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
          0: OnOff:= OnOff and $fcfc;
          1: OnOff:= OnOff and $f0f0;
          2: OnOff:= OnOff and $c0c0;
          else OnOff:= 0;
        end;
      end; {else}
    end; {with}
    MyDDSurface.DisplayCelPartXor(x2,y2,OnOff,DragColor);
  end; {for i}
  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_2Drag(XOffset,YOffset: integer; DisplayQ: boolean);
var
  OnOff: integer;
  x1,y1,x2,y2: integer;
  XLeft, XTop, Xright, XBottom: integer;
  LikeP: TSmall;
begin
  //Zoomfactor is -2; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  x1:= coor.x * 4;
  y1:= coor.y * 4;
  Inc(x1,XOffset + StartPoint.x);
  Inc(y1,YOffset + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  x2:= x1;
  y2:= y1;
  OnOff:= 0;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      if (TInt(LikeP)[0] and $0000ffff) <> 0 then OnOff:= OnOff or $8000;
      if (TInt(LikeP)[0] and $ffff0000) <> 0 then OnOff:= OnOff or $4000;
      if (TInt(LikeP)[1] and $0000ffff) <> 0 then OnOff:= OnOff or $2000;
      if (TInt(LikeP)[1] and $ffff0000) <> 0 then OnOff:= OnOff or $1000;
      if (TInt(LikeP)[2] and $0000ffff) <> 0 then OnOff:= OnOff or $0800;
      if (TInt(LikeP)[2] and $ffff0000) <> 0 then OnOff:= OnOff or $0400;
      if (TInt(LikeP)[3] and $0000ffff) <> 0 then OnOff:= OnOff or $0200;
      if (TInt(LikeP)[3] and $ffff0000) <> 0 then OnOff:= OnOff or $0100;
      if (TInt(LikeP)[4] and $0000ffff) <> 0 then OnOff:= OnOff or $0080;
      if (TInt(LikeP)[4] and $ffff0000) <> 0 then OnOff:= OnOff or $0040;
      if (TInt(LikeP)[5] and $0000ffff) <> 0 then OnOff:= OnOff or $0020;
      if (TInt(LikeP)[5] and $ffff0000) <> 0 then OnOff:= OnOff or $0010;
      if (TInt(LikeP)[6] and $0000ffff) <> 0 then OnOff:= OnOff or $0008;
      if (TInt(LikeP)[6] and $ffff0000) <> 0 then OnOff:= OnOff or $0004;
      if (TInt(LikeP)[7] and $0000ffff) <> 0 then OnOff:= OnOff or $0002;
      if (TInt(LikeP)[7] and $ffff0000) <> 0 then OnOff:= OnOff or $0001;
    end; {true}
    else begin
      if (TInt(p)[0] and $0000ffff) <> 0 then OnOff:= OnOff or $8000;
      if (TInt(p)[0] and $ffff0000) <> 0 then OnOff:= OnOff or $4000;
      if (TInt(p)[1] and $0000ffff) <> 0 then OnOff:= OnOff or $2000;
      if (TInt(p)[1] and $ffff0000) <> 0 then OnOff:= OnOff or $1000;
      if (TInt(p)[2] and $0000ffff) <> 0 then OnOff:= OnOff or $0800;
      if (TInt(p)[2] and $ffff0000) <> 0 then OnOff:= OnOff or $0400;
      if (TInt(p)[3] and $0000ffff) <> 0 then OnOff:= OnOff or $0200;
      if (TInt(p)[3] and $ffff0000) <> 0 then OnOff:= OnOff or $0100;
      if (TInt(p)[4] and $0000ffff) <> 0 then OnOff:= OnOff or $0080;
      if (TInt(p)[4] and $ffff0000) <> 0 then OnOff:= OnOff or $0040;
      if (TInt(p)[5] and $0000ffff) <> 0 then OnOff:= OnOff or $0020;
      if (TInt(p)[5] and $ffff0000) <> 0 then OnOff:= OnOff or $0010;
      if (TInt(p)[6] and $0000ffff) <> 0 then OnOff:= OnOff or $0008;
      if (TInt(p)[6] and $ffff0000) <> 0 then OnOff:= OnOff or $0004;
      if (TInt(p)[7] and $0000ffff) <> 0 then OnOff:= OnOff or $0002;
      if (TInt(p)[7] and $ffff0000) <> 0 then OnOff:= OnOff or $0001;
    end; {false:}
  end; {case}
  if OnOff <> 0 then with DrawBound do begin
    if ((x2 > Left) and ((x2+CelSpace4) < Right)
    and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
    {do nothing because were are not near the border}
    else begin
      XLeft:= Left - x2;
      XTop:= Top - y2;
      XRight:= (x2 + CelSpace4) - Right;
      XBottom:= (y2 + CelSpace4) - Bottom;
      //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
      if XLeft > 0 then case ((XLeft -1) div CelSpace) of
        0: OnOff:= OnOff and $55ff;
        1: OnOff:= OnOff and $00ff;
        2: OnOff:= OnOff and $0055;
        else OnOff:= 0;
      end; {case}
      if XTop > 0 then case ((XTop -1) div CelSpace) of
        0: OnOff:= OnOff and $3f3f;
        1: OnOff:= OnOff and $0f0f;
        2: OnOff:= OnOff and $0303;
        else OnOff:= 0;
      end;
      if (XRight) > 0 then case ((XRight -1) div CelSpace) of
        0: OnOff:= OnOff and $ffaa;
        1: OnOff:= OnOff and $ff00;
        2: OnOff:= OnOff and $aa00;
        else OnOff:= 0;
      end; {case}
      if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
        0: OnOff:= OnOff and $fcfc;
        1: OnOff:= OnOff and $f0f0;
        2: OnOff:= OnOff and $c0c0;
        else OnOff:= 0;
      end; {case}
    end; {else}
  end; {with}
  MyDDSurface.DisplayCelPartXor(x2,y2,OnOff,DragColor);

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_3Drag(XOffset,YOffset: integer; DisplayQ: boolean);
var
  OnOff: integer;
  x1,y1,x2,y2: integer;
  XLeft, XTop, Xright, XBottom: integer;
  LikeP: TSmall;
begin
  //Zoomfactor is -3; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  x1:= coor.x * 2;
  y1:= coor.y * 2;
  Inc(x1,XOffset + StartPoint.x);
  Inc(y1,YOffset + StartPoint.y);

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  x2:= x1;
  y2:= y1;
  OnOff:= 0;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      if (TInt(LikeP)[0] or TInt(LikeP)[1]) <> 0 then OnOff:= OnOff or $8000;
      if (TInt(LikeP)[2] or TInt(LikeP)[3]) <> 0 then OnOff:= OnOff or $2000;
      if (TInt(LikeP)[4] or TInt(LikeP)[5]) <> 0 then OnOff:= OnOff or $4000;
      if (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0 then OnOff:= OnOff or $1000;
    end; {true}
    else begin
      if (TInt(p)[0] or TInt(p)[1]) <> 0 then OnOff:= OnOff or $8000;
      if (TInt(p)[2] or TInt(p)[3]) <> 0 then OnOff:= OnOff or $2000;
      if (TInt(p)[4] or TInt(p)[5]) <> 0 then OnOff:= OnOff or $4000;
      if (TInt(p)[6] or TInt(p)[7]) <> 0 then OnOff:= OnOff or $1000;
    end; {false:}
  end; {case}
  if OnOff <> 0 then with DrawBound do begin
    if ((x2 > Left) and ((x2+CelSpace2) < Right)
    and (y2 > Top) and ((y2+CelSpace2) < Bottom)) then
    {do nothing because were are not near the border}
    else begin
      XLeft:= Left - x2;
      XTop:= Top - y2;
      XRight:= (x2 + CelSpace2) - Right;
      XBottom:= (y2 + CelSpace2) - Bottom;
      //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
      if XLeft > 0 then case ((XLeft -1) ) of
        0: OnOff:= OnOff and $55ff;
        else OnOff:= 0;
      end; {case}
      if XTop > 0 then case ((XTop -1) ) of
        0: OnOff:= OnOff and $3f3f;
        else OnOff:= 0;
      end;
      if (XRight) > 0 then case ((XRight -1) ) of
        0: OnOff:= OnOff and $aa00;
        else OnOff:= 0;
      end; {case}
      if (XBottom) > 0 then case ((XBottom -1) ) of
        0: OnOff:= OnOff and $c0c0;
        else OnOff:= 0;
      end;
    end; {else}
  end; {with}
  MyDDSurface.DisplayCelPartXor(x2,y2,OnOff,DragColor);

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_4Drag(XOffset,YOffset: integer; DisplayQ: boolean);
var
  OnOff: integer;
  x2,y2: integer;
  LikeP: TSmall;
  Color: integer;
begin
  //Zoomfactor is -4; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  //x1:= x * 1;
  //y1:= y * 1;
  x2:= coor.x + XOffset + StartPoint.x;
  y2:= coor.y + YOffset + StartPoint.y;

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  OnOff:= $8000;
  Color:= 0; //Xor 0 leaves cells intact.
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      if (TInt(LikeP)[0] or TInt(LikeP)[1]) or (TInt(LikeP)[2] or TInt(LikeP)[3]) or
         (TInt(LikeP)[4] or TInt(LikeP)[5]) or (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0
      then Color:= DragColor;
    end; {true}
    else begin
      if (TInt(p)[0] or TInt(p)[1]) or (TInt(p)[2] or TInt(p)[3]) or
         (TInt(p)[4] or TInt(p)[5]) or (TInt(p)[6] or TInt(p)[7]) <> 0
      then Color:= DragColor;
    end; {false:}
  end; {case}
  with DrawBound do begin
    if ((x2 > Left) and ((x2+CelSpace) < Right)
    and (y2 > Top) and ((y2+CelSpace) < Bottom)) then begin
      MyDDSurface.DisplayCelPartXor(x2,y2,OnOff,Color);
    end; {if}
  end; {with}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_5Drag(XOffset,YOffset: integer; DisplayQ: boolean);
var
  OnOff: integer;
  x1,y1: integer;
  x2,y2: integer;
  LikeP: TSmall;
  IsOn: boolean;
begin
  //Zoomfactor is -5; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  x1:= coor.x div 2;
  y1:= coor.y div 2;
  x2:= x1 + XOffset + StartPoint.x;
  y2:= y1 + YOffset + StartPoint.y;

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  OnOff:= $8000;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      IsOn:= (TInt(LikeP)[0] or TInt(LikeP)[1]) or (TInt(LikeP)[2] or TInt(LikeP)[3]) or
         (TInt(LikeP)[4] or TInt(LikeP)[5]) or (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0;
    end; {true}
    else begin
      IsOn:= (TInt(p)[0] or TInt(p)[1]) or (TInt(p)[2] or TInt(p)[3]) or
         (TInt(p)[4] or TInt(p)[5]) or (TInt(p)[6] or TInt(p)[7]) <> 0;
    end; {false:}
  end; {case}
  if IsOn then with DrawBound do begin
    if ((x2 > Left) and ((x2+CelSpace) < Right)
    and (y2 > Top) and ((y2+CelSpace) < Bottom)) then begin
      MyDDSurface.DisplayCelPartXor(x2,y2,OnOff,DragColor);
    end; {if}
  end; {with}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_6Drag(XOffset,YOffset: integer; DisplayQ: boolean);
var
  OnOff: integer;
  x1,y1: integer;
  x2,y2: integer;
  LikeP: TSmall;
  IsOn: boolean;
begin
  //Zoomfactor is -6; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  x1:= coor.x div 4;
  y1:= coor.y div 4;
  x2:= x1 + XOffset + StartPoint.x;
  y2:= y1 + YOffset + StartPoint.y;

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  OnOff:= $8000;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      IsOn:= (TInt(LikeP)[0] or TInt(LikeP)[1]) or (TInt(LikeP)[2] or TInt(LikeP)[3]) or
         (TInt(LikeP)[4] or TInt(LikeP)[5]) or (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0;
    end; {true}
    else begin
      IsOn:= (TInt(p)[0] or TInt(p)[1]) or (TInt(p)[2] or TInt(p)[3]) or
         (TInt(p)[4] or TInt(p)[5]) or (TInt(p)[6] or TInt(p)[7]) <> 0;
    end; {false:}
  end; {case}
  if IsOn then with DrawBound do begin
    if ((x2 > Left) and ((x2+CelSpace) < Right)
    and (y2 > Top) and ((y2+CelSpace) < Bottom)) then begin
      MyDDSurface.DisplayCelPartXor(x2,y2,OnOff,DragColor);
    end; {if}
  end; {with}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_7Drag(XOffset,YOffset: integer; DisplayQ: boolean);
var
  OnOff: integer;
  x1,y1: integer;
  x2,y2: integer;
  LikeP: TSmall;
  IsOn: boolean;
begin
  //Zoomfactor is -7; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  x1:= coor.x div 8;
  y1:= coor.y div 8;
  x2:= x1 + XOffset + StartPoint.x;
  y2:= y1 + YOffset + StartPoint.y;

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  OnOff:= $8000;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      IsOn:= (TInt(LikeP)[0] or TInt(LikeP)[1]) or (TInt(LikeP)[2] or TInt(LikeP)[3]) or
         (TInt(LikeP)[4] or TInt(LikeP)[5]) or (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0;
    end; {true}
    else begin
      IsOn:= (TInt(p)[0] or TInt(p)[1]) or (TInt(p)[2] or TInt(p)[3]) or
         (TInt(p)[4] or TInt(p)[5]) or (TInt(p)[6] or TInt(p)[7]) <> 0;
    end; {false:}
  end; {case}
  if IsOn then with DrawBound do begin
    if ((x2 > Left) and ((x2+CelSpace) < Right)
    and (y2 > Top) and ((y2+CelSpace) < Bottom)) then begin
      MyDDSurface.DisplayCelPartXor(x2,y2,OnOff,DragColor);
    end; {if}
  end; {with}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)

procedure TLifeCel.DisplayZoom_8Drag(XOffset,YOffset: integer; DisplayQ: boolean);
var
  OnOff: integer;
  x1,y1: integer;
  x2,y2: integer;
  LikeP: TSmall;
  IsOn: boolean;
begin
  //Zoomfactor is -7; because of reduction, seperate routine for each case.
  //CelSpace is left at 1.
  x1:= coor.x div 16;
  y1:= coor.y div 16;
  x2:= x1 + XOffset + StartPoint.x;
  y2:= y1 + YOffset + StartPoint.y;

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  OnOff:= $8000;
  case DisplayQ of
    true: begin
      LikeP:= ConvertQtoP;
      IsOn:= (TInt(LikeP)[0] or TInt(LikeP)[1]) or (TInt(LikeP)[2] or TInt(LikeP)[3]) or
         (TInt(LikeP)[4] or TInt(LikeP)[5]) or (TInt(LikeP)[6] or TInt(LikeP)[7]) <> 0;
    end; {true}
    else begin
      IsOn:= (TInt(p)[0] or TInt(p)[1]) or (TInt(p)[2] or TInt(p)[3]) or
         (TInt(p)[4] or TInt(p)[5]) or (TInt(p)[6] or TInt(p)[7]) <> 0;
    end; {false:}
  end; {case}
  if IsOn then with DrawBound do begin
    if ((x2 > Left) and ((x2+CelSpace) < Right)
    and (y2 > Top) and ((y2+CelSpace) < Bottom)) then begin
      MyDDSurface.DisplayCelPartXor(x2,y2,OnOff,DragColor);
    end; {if}
  end; {with}

  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  (**)



(*procedure TLifeCel.DisplayAll(XOffset, YOffset: Integer; DisplayQ: boolean);
var
  x1,y1: integer;
  x2,y2: integer;
  OnOff: integer;
  Onn,Off: TSmall;
  Color: integer;
  Clear:Boolean;
  XLeft,XTop,XRight,XBottom: integer;
  i: integer;
begin
  x1:= x * 16;
  y1:= y * 16;
  Inc(x1,integer(DisplayQ));
  Inc(y1,integer(DisplayQ));
  x1:= x1 * CelSpace;
  y1:= y1 * CelSpace;
  Inc(x1,XOffset + StartPoint.x);
  Inc(y1,yOffset + StartPoint.y);

  x2:= x1;
  y2:= y1;

  {$ifdef time}
  MyTimer.StartNow;
  {$endif}
  {$ifdef time}
  MyTimer.StopNow;
  CumDiff:= CumDiff + MyTimer.TimePast.Totaal;
  MyTimer.StartNow;
  {$endif}

  if DisplayQ then begin
    Onn:= TSmall(q);
    for i:= 0 to 15 do Off[i]:= not q[i];
  end {if}
  else begin
    Onn:= TSmall(p);
    for i:= 0 to 15 do Off[i]:= not p[i];
  end; {else}



  //for i:= 0 to 15 do begin
  //On pixels first;
  //00000000000000000000000000000000000000000000000000
  begin
    OnOff:= Onn[0];
    Color:= ForeColor;
    for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      OnOff:= Off[0];
      Color:= BackColor;
    end; {for wissen}
  end; {if}
  //111111111111111111111111111111111111111111111111111111111
  begin
    x2:= x1 + CelSpace4;

    OnOff:= Onn[1];
    Color:= ForeColor;
    for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      OnOff:= Off[1];
      Color:= BackColor;
    end; {for wissen}
  end; {if}
  //22222222222222222222222222222222222222222222222222
  begin
    begin x2:= x1; y2:= y1 + CelSpace4; end;

    OnOff:= Onn[2];
    Color:= ForeColor;
    for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      OnOff:= Off[2];
      Color:= BackColor;
    end; {for wissen}
  end; {if}
  //3333333333333333333333333333333333333333333333333333
  begin
    begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace4; end;

    OnOff:= Onn[3];
    Color:= ForeColor;
    for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      OnOff:= Off[3];
      Color:= BackColor;
    end; {for wissen}
  end; {if}
  //44444444444444444444444444444444444444444444444444444444
  begin
    begin x2:= x1; y2:= y1 + CelSpace8; end;

    OnOff:= Onn[4];
    Color:= ForeColor;
    for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      OnOff:= Off[4];
      Color:= BackColor;
    end; {for wissen}
  end; {if}
  //55555555555555555555555555555555555555555555555555
  begin
    begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace8; end;

    OnOff:= Onn[5];
    Color:= ForeColor;
    for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      OnOff:= Off[5];
      Color:= BackColor;
    end; {for wissen}
  end; {if}
  //6666666666666666666666666666666666666666666666666
  begin
    begin x2:= x1; y2:= y1 + CelSpace12; end;

    OnOff:= Onn[6];
    Color:= ForeColor;
    for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      OnOff:= Off[6];
      Color:= BackColor;
    end; {for wissen}
  end; {if}
  //777777777777777777777777777777777777777777
  begin
    begin x2:= x1 + CelSpace4; y2:= y1 + CelSpace12; end;

    OnOff:= Onn[7];
    Color:= ForeColor;
    for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      OnOff:= Off[7];
      Color:= BackColor;
    end; {for wissen}
  end; {if}
  //888888888888888888888888888888888888888888888888
  begin
    begin x2:= x1 + CelSpace8; y2:= y1; end;
      
    OnOff:= Onn[8];
    Color:= ForeColor;
    for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      OnOff:= Off[8];
      Color:= BackColor;
    end; {for wissen}
  end; {if}
  //999999999999999999999999999999999999999999999999999
  begin
    begin x2:= x1 + CelSpace12; y2:= y1; end;

    OnOff:= Onn[9];
    Color:= ForeColor;
    for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      OnOff:= Off[9];
      Color:= BackColor;
    end; {for wissen}
  end; {if}
  //aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
  begin
    begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace4; end;

    OnOff:= Onn[10];
    Color:= ForeColor;
    for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      OnOff:= Off[10];
      Color:= BackColor;
    end; {for wissen}
  end; {if}
  //bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
  begin
    begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace4; end;
      
    OnOff:= Onn[11];
    Color:= ForeColor;
    for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      OnOff:= Off[11];
      Color:= BackColor;
    end; {for wissen}
  end; {if}
  //cccccccccccccccccccccccccccccccccccccccccccccc
  begin
    begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace8; end;

    OnOff:= Onn[12];
    Color:= ForeColor;
    for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      OnOff:= Off[12];
      Color:= BackColor;
    end; {for wissen}
  end; {if}
  //ddddddddddddddddddddddddddddddddddddddddddddddddd
  begin
    begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace8; end;

    OnOff:= Onn[13];
    Color:= ForeColor;
    for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      OnOff:= Off[13];
      Color:= BackColor;
    end; {for wissen}
  end; {if}
  //eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
  begin
    begin x2:= x1 + CelSpace8; y2:= y1 + CelSpace12; end;

    OnOff:= Onn[14];
    Color:= ForeColor;
    for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      OnOff:= Off[14];
      Color:= BackColor;
    end; {for wissen}
  end; {if}
  //fffffffffffffffffffffffffffffffffffffffffffffffff
  begin
    begin x2:= x1 + CelSpace12; y2:= y1 + CelSpace12; end;

    OnOff:= Onn[15];
    Color:= ForeColor;
    for Clear:= false to true do begin
      if OnOff <> 0 then with DrawBound do begin
        if ((x2 > Left) and ((x2+CelSpace4) < Right)
        and (y2 > Top) and ((y2+CelSpace4) < Bottom)) then
        {do nothing because were are not near the border}
        else begin
          XLeft:= Left - x2;
          XTop:= Top - y2;
          XRight:= (x2 + CelSpace4) - Right;
          XBottom:= (y2 + CelSpace4) - Bottom;
          //if XLeft etc > 0 then we have crossed the border, so blot out a bit}
          if XLeft > 0 then case ((XLeft -1) div CelSpace) of
            0: OnOff:= OnOff and $55ff;
            1: OnOff:= OnOff and $00ff;
            2: OnOff:= OnOff and $0055;
            else OnOff:= 0;
          end; {case}
          if XTop > 0 then case ((XTop -1) div CelSpace) of
            0: OnOff:= OnOff and $3f3f;
            1: OnOff:= OnOff and $0f0f;
            2: OnOff:= OnOff and $0303;
            else OnOff:= 0;
          end;
          if (XRight) > 0 then case ((XRight -1) div CelSpace) of
            0: OnOff:= OnOff and $ffaa;
            1: OnOff:= OnOff and $ff00;
            2: OnOff:= OnOff and $aa00;
            else OnOff:= 0;
          end; {case}
          if (XBottom) > 0 then case ((XBottom -1) div CelSpace) of
            0: OnOff:= OnOff and $fcfc;
            1: OnOff:= OnOff and $f0f0;
            2: OnOff:= OnOff and $c0c0;
            else OnOff:= 0;
          end;
        end; {else}
        MyDDSurface.DisplayCelPart(x2,y2,OnOff,Color)
      end; {if}

      //Now off pixels
      OnOff:= Off[15];
      Color:= BackColor;
    end; {for wissen}
  end; {if}
  //end; {for i}
  {$ifdef time}
  MyTimer.StopNow;
  CumDisp:= CumDisp + MyTimer.TimePast.Totaal;
  {$endif}
end;  {} (**)




function TLifeCel.NumberOfCels(QCycle: Boolean): integer;
var
  a,i: cardinal;
begin
  Result:= 0;
  for i:= 0 to 7 do begin
    if QCycle then a:= TInt(q)[i] else a:= TInt(p)[i];
    Inc(Result,a and  $00000001);        //1
    Inc(Result,(a and $00000002) shr 1);//2
    Inc(Result,(a and $00000004) shr 2);//3
    Inc(Result,(a and $00000008) shr 3);//4
    Inc(Result,(a and $00000010) shr 4);//5
    Inc(Result,(a and $00000020) shr 5);//6
    Inc(Result,(a and $00000040) shr 6);//7
    Inc(Result,(a and $00000080) shr 7);//8
    Inc(Result,(a and $00000100) shr 8);//9
    Inc(Result,(a and $00000200) shr 9);//10
    Inc(Result,(a and $00000400) shr 10);//11
    Inc(Result,(a and $00000800) shr 11);//12
    Inc(Result,(a and $00001000) shr 12);//13
    Inc(Result,(a and $00002000) shr 13);//14
    Inc(Result,(a and $00004000) shr 14);//15
    Inc(Result,(a and $00008000) shr 15);//16
    Inc(Result,(a and $00010000) shr 16);//17
    Inc(Result,(a and $00020000) shr 17);//18
    Inc(Result,(a and $00040000) shr 18);//19
    Inc(Result,(a and $00080000) shr 19);//20
    Inc(Result,(a and $00100000) shr 20);//21
    Inc(Result,(a and $00200000) shr 21);//22
    Inc(Result,(a and $00400000) shr 22);//23
    Inc(Result,(a and $00800000) shr 23);//24
    Inc(Result,(a and $01000000) shr 24);//25
    Inc(Result,(a and $02000000) shr 25);//26
    Inc(Result,(a and $04000000) shr 26);//27
    Inc(Result,(a and $08000000) shr 27);//28
    Inc(Result,(a and $10000000) shr 28);//29
    Inc(Result,(a and $20000000) shr 29);//30
    Inc(Result,(a and $40000000) shr 30);//31
    Inc(Result,(a {and $80000000}) shr 31);//32
  end; {for i}
end;

function TLifeCel.IsStable: boolean;
begin
  //Result:= (flags and $0006) <> 0;
  {if not Result then} //Result:= (NumberOfCels(true) + NumberOfCels(false) = 0);
  Result:= false;
end;

function TLifeCel.IsEmpty(QCycle: boolean): boolean;
begin
  if QCycle then begin
		Result:= (TInt(q)[0] or TInt(q)[1] or TInt(q)[2] or TInt(q)[3] or
							TInt(q)[4] or TInt(q)[5] or TInt(q)[6] or TInt(q)[7]) = 0;
	end {if}
	else begin
		Result:= (TInt(p)[0] or TInt(p)[1] or TInt(p)[2] or TInt(p)[3] or
							TInt(p)[4] or TInt(p)[5] or TInt(p)[6] or TInt(p)[7]) = 0;
	end; {else}
end;


(*procedure TLifeCel.ClearRect(ARect: TRect; QCycle: boolean);
var
  MyRect: TRect;
begin
  with MyRect do begin
    Left:= x*16;
    Right:= x*16+16;
    Top:= y*16;
    Bottom:= y*16+16;
    if IntersectRect(MyRect,MyRect,ARect) then begin
    end;
  end;
end; (**)

function TLifeCel.GetCelSum(QCycle: boolean): integer;
begin
  case QCycle of
    true: begin
      Result:= TInt(q)[0] or TInt(q)[1] or TInt(q)[2] or TInt(q)[3] or
               TInt(q)[4] or TInt(q)[5] or TInt(q)[6] or TInt(q)[7];
    end; {QCycle}
    else begin
      Result:= TInt(p)[0] or TInt(p)[1] or TInt(p)[2] or TInt(p)[3] or
               TInt(p)[4] or TInt(p)[5] or TInt(p)[6] or TInt(p)[7];
    end; {PCycle}
  end; {case}
end;

function TLifeCel.GetChecksum(QCycle: boolean): integer;
begin
  case QCycle of
    true: begin
      Result:= TInt(q)[0] xor TInt(q)[1] xor TInt(q)[2] xor TInt(q)[3] xor
               TInt(q)[4] xor TInt(q)[5] xor TInt(q)[6] xor TInt(q)[7];
    end; {QCycle}
    else begin
      Result:= TInt(p)[0] xor TInt(p)[1] xor TInt(p)[2] xor TInt(p)[3] xor
               TInt(p)[4] xor TInt(p)[5] xor TInt(p)[6] xor TInt(p)[7];
    end; {PCycle}
  end; {case}
end;

function TLifeCel.GetCelDiff(c2: TLifeCel; QCycle, QCycle2: boolean): integer;
var
  cp: TSmall;
begin
  if QCycle = QCycle2 then begin
    case QCycle of
      true: begin
        Result:= (TInt(q)[0] xor TInt(c2.q)[0]) or
                 (TInt(q)[1] xor TInt(c2.q)[1]) or
                 (TInt(q)[2] xor TInt(c2.q)[2]) or
                 (TInt(q)[3] xor TInt(c2.q)[3]) or
                 (TInt(q)[4] xor TInt(c2.q)[4]) or
                 (TInt(q)[5] xor TInt(c2.q)[5]) or
                 (TInt(q)[6] xor TInt(c2.q)[6]) or
                 (TInt(q)[7] xor TInt(c2.q)[7]);
      end; {QCycle}
      else begin
        Result:= (TInt(p)[0] xor TInt(c2.p)[0]) or
                 (TInt(p)[1] xor TInt(c2.p)[1]) or
                 (TInt(p)[2] xor TInt(c2.p)[2]) or
                 (TInt(p)[3] xor TInt(c2.p)[3]) or
                 (TInt(p)[4] xor TInt(c2.p)[4]) or
                 (TInt(p)[5] xor TInt(c2.p)[5]) or
                 (TInt(p)[6] xor TInt(c2.p)[6]) or
                 (TInt(p)[7] xor TInt(c2.p)[7]);
      end; {PCycle}
    end; {case}
  end {if InPhase}
  else begin
    if QCycle then begin
      cp:= ConvertQtoP;
      Result:= (TInt(cp)[0] xor TInt(c2.p)[0]) or
               (TInt(cp)[1] xor TInt(c2.p)[1]) or
               (TInt(cp)[2] xor TInt(c2.p)[2]) or
               (TInt(cp)[3] xor TInt(c2.p)[3]) or
               (TInt(cp)[4] xor TInt(c2.p)[4]) or
               (TInt(cp)[5] xor TInt(c2.p)[5]) or
               (TInt(cp)[6] xor TInt(c2.p)[6]) or
               (TInt(cp)[7] xor TInt(c2.p)[7]);
    end {QCycle}
    else begin
      cp:= c2.ConvertQtoP;
      Result:= (TInt(p)[0] xor TInt(cp)[0]) or
               (TInt(p)[1] xor TInt(cp)[1]) or
               (TInt(p)[2] xor TInt(cp)[2]) or
               (TInt(p)[3] xor TInt(cp)[3]) or
               (TInt(p)[4] xor TInt(cp)[4]) or
               (TInt(p)[5] xor TInt(cp)[5]) or
               (TInt(p)[6] xor TInt(cp)[6]) or
               (TInt(p)[7] xor TInt(cp)[7]);
    end; {PCycle}
  end; {OutOfPhase}
end;

procedure TLifeCel.Clear(QCycle: boolean);
begin
  if QCycle then begin
		TInt(q)[0]:= 0;
		TInt(q)[1]:= 0;
		TInt(q)[2]:= 0;
		TInt(q)[3]:= 0;
		TInt(q)[4]:= 0;
		TInt(q)[5]:= 0;
		TInt(q)[6]:= 0;
		TInt(q)[7]:= 0;
	end {if}
	else begin
		TInt(p)[0]:= 0;
		TInt(p)[1]:= 0;
		TInt(p)[2]:= 0;
		TInt(p)[3]:= 0;
		TInt(p)[4]:= 0;
		TInt(p)[5]:= 0;
		TInt(p)[6]:= 0;
		TInt(p)[7]:= 0;
  end; {else}
end;

{$WARN BOUNDS_ERROR OFF}
procedure TLifeCel.FillBlack(QCycle: boolean);
begin
  if QCycle then begin
		TInt(q)[0]:= $FFFFFFFF;
		TInt(q)[1]:= $FFFFFFFF;
		TInt(q)[2]:= $FFFFFFFF;
		TInt(q)[3]:= $FFFFFFFF;
		TInt(q)[4]:= $FFFFFFFF;
		TInt(q)[5]:= $FFFFFFFF;
		TInt(q)[6]:= $FFFFFFFF;
		TInt(q)[7]:= $FFFFFFFF;
	end {if}
	else begin
		TInt(p)[0]:= $FFFFFFFF;
		TInt(p)[1]:= $FFFFFFFF;
		TInt(p)[2]:= $FFFFFFFF;
		TInt(p)[3]:= $FFFFFFFF;
		TInt(p)[4]:= $FFFFFFFF;
		TInt(p)[5]:= $FFFFFFFF;
		TInt(p)[6]:= $FFFFFFFF;
		TInt(p)[7]:= $FFFFFFFF;
  end; {else}
end;
{$WARN BOUNDS_ERROR ON}

procedure TLifeCel.Invert(QCycle: boolean);
begin
  if QCycle then begin
		TInt(q)[0]:= not(TInt(q)[0]);
		TInt(q)[1]:= not(TInt(q)[1]);
		TInt(q)[2]:= not(TInt(q)[2]);
		TInt(q)[3]:= not(TInt(q)[3]);
		TInt(q)[4]:= not(TInt(q)[4]);
		TInt(q)[5]:= not(TInt(q)[5]);
		TInt(q)[6]:= not(TInt(q)[6]);
		TInt(q)[7]:= not(TInt(q)[7]);
	end {if}
	else begin
		TInt(p)[0]:= not(TInt(p)[0]);
		TInt(p)[1]:= not(TInt(p)[1]);
		TInt(p)[2]:= not(TInt(p)[2]);
		TInt(p)[3]:= not(TInt(p)[3]);
		TInt(p)[4]:= not(TInt(p)[4]);
		TInt(p)[5]:= not(TInt(p)[5]);
		TInt(p)[6]:= not(TInt(p)[6]);
		TInt(p)[7]:= not(TInt(p)[7]);
  end; {else}
end;


{$WARN BOUNDS_ERROR OFF}
const
  XLookup: array[0..15] of integer =(0,0,0,0,0,0,0,0,4,4,4,4,4,4,4,4);
  YLookup: array[0..15] of integer =(0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3);
  HorzMaskRightLookup: array[0..31] of integer =
     {x,y}
    ({0,0}$c0c0c0c0,{1,0}$c0c040c0,{2,0}$c0c000c0,{3,0}$c0c00040,
     {4,0}$c0c00000,{5,0}$40c00000,{6,0}$00c00000,{7,0}$00400000,
     {0,1}$30303030,{1,1}$30301030,{2,1}$30300030,{3,1}$30300010,
     {4,1}$30300000,{5,1}$10300000,{6,1}$00300000,{7,1}$00100000,
     {0,2}$0c0c0c0c,{1,2}$0c0c040c,{2,2}$0c0c000c,{3,2}$0c0c0004,
     {4,2}$0c0c0000,{5,2}$040c0000,{6,2}$000c0000,{7,2}$00040000,
     {0,3}$03030303,{1,3}$03030103,{2,3}$03030003,{3,3}$03030001,
     {4,3}$03030000,{5,3}$01030000,{6,3}$00030000,{7,3}$00010000);
{$WARN BOUNDS_ERROR ON}

procedure TLifeCel.DrawHorzLineRight(x1,y1: integer; State: TLineDrawState; QCycle: boolean);
var
  Part, Mask: integer;
begin
  Part:= XLookup[x1]+YLookUp[y1];
  Mask:= HorzMaskRightLookup[(x1 and 7) + ((y1 and 3) * 8)];
  case QCycle of
    true: case State of
      lds_On: TInt(q)[Part]:= Tint(q)[Part] or Mask;
      lds_Off: TInt(q)[Part]:= TInt(q)[Part] and not(Mask);
      lds_Xor: TInt(q)[Part]:= Tint(q)[Part] xor Mask;
    end; {Qcycle}
    false: case State of
      lds_On: TInt(p)[Part]:= Tint(p)[Part] or Mask;
      lds_Off: TInt(p)[Part]:= TInt(p)[Part] and not(Mask);
      lds_Xor: TInt(p)[Part]:= Tint(p)[Part] xor Mask;
    end; {PQcyle}
  end; {case}
  if Part < 4 then begin
    Inc(Part,4);
    Mask:= HorzMaskRightLookup[(y1 and 3)*8];
    case QCycle of
      true: case State of
        lds_On: TInt(q)[Part]:= Tint(q)[Part] or Mask;
        lds_Off: TInt(q)[Part]:= TInt(q)[Part] and not(Mask);
        lds_Xor: TInt(q)[Part]:= Tint(q)[Part] xor Mask;
      end; {Qcycle}
      false: case State of
        lds_On: TInt(p)[Part]:= Tint(p)[Part] or Mask;
        lds_Off: TInt(p)[Part]:= TInt(p)[Part] and not(Mask);
        lds_Xor: TInt(p)[Part]:= Tint(p)[Part] xor Mask;
      end; {PQcyle}
    end; {case}
  end; {if}
end;

{$WARN BOUNDS_ERROR OFF}
const
  VertMaskDownLookup: array[0..31] of integer =
    ({0,0}$0000aa00,{1,0}$00005500,{2,0}$000000aa,{3,0}$00000055,
     {4,0}$aa000000,{5,0}$55000000,{6,0}$00aa0000,{7,0}$00550000,
     {0,1}$00002a00,{1,1}$00001500,{2,1}$0000002a,{3,1}$00000015,
     {4,1}$2a000000,{5,1}$15000000,{6,1}$002a0000,{7,1}$00150000,
     {0,2}$00000a00,{1,2}$00000500,{2,2}$0000000a,{3,2}$00000005,
     {4,2}$0a000000,{5,2}$05000000,{6,2}$000a0000,{7,2}$00050000,
     {0,3}$00000200,{1,3}$00000100,{2,3}$00000002,{3,3}$00000001,
     {4,3}$02000000,{5,3}$01000000,{6,3}$00020000,{7,3}$00010000);
{$WARN BOUNDS_ERROR ON}

procedure TLifeCel.DrawVertLineDown(x1,y1: integer; State: TLineDrawState; QCycle: boolean);
var
  Part, Mask: integer;
begin
  Part:= XLookup[x1]+YLookUp[y1];
  Mask:= VertMaskDownLookup[(x1 and 7) + ((y1 and 3) * 8)];
  case QCycle of
    true: case State of
      lds_On: TInt(q)[Part]:= Tint(q)[Part] or Mask;
      lds_Off: TInt(q)[Part]:= TInt(q)[Part] and not(Mask);
      lds_Xor: TInt(q)[Part]:= Tint(q)[Part] xor Mask;
    end; {Qcycle}
    false: case State of
      lds_On: TInt(p)[Part]:= Tint(p)[Part] or Mask;
      lds_Off: TInt(p)[Part]:= TInt(p)[Part] and not(Mask);
      lds_Xor: TInt(p)[Part]:= Tint(p)[Part] xor Mask;
    end; {PQcyle}
  end; {case}
  while ((Part and 3) < 3) do begin
    Inc(Part);
    Mask:= VertMaskDownLookup[x1 and 7];
    case QCycle of
      true: case State of
        lds_On: TInt(q)[Part]:= Tint(q)[Part] or Mask;
        lds_Off: TInt(q)[Part]:= TInt(q)[Part] and not(Mask);
        lds_Xor: TInt(q)[Part]:= Tint(q)[Part] xor Mask;
      end; {Qcycle}
      false: case State of
        lds_On: TInt(p)[Part]:= Tint(p)[Part] or Mask;
        lds_Off: TInt(p)[Part]:= TInt(p)[Part] and not(Mask);
        lds_Xor: TInt(p)[Part]:= Tint(p)[Part] xor Mask;
      end; {PQcyle}
    end; {case}
  end; {while}
end;

{$WARN BOUNDS_ERROR OFF}
const
  HorzMaskLeftLookup: array[0..31] of integer =
     {x,y}
    ({0,0}$00008000,{1,0}$0000c000,{2,0}$0000c080,{3,0}$0000c0c0,
     {4,0}$8000c0c0,{5,0}$c000c0c0,{6,0}$c080c0c0,{7,0}$c0c0c0c0,
     {0,1}$00002000,{1,1}$00003000,{2,1}$00003020,{3,1}$00003030,
     {4,1}$20003030,{5,1}$30003030,{6,1}$30203030,{7,1}$30303030,
     {0,2}$00000800,{1,2}$00000c00,{2,2}$00000c08,{3,2}$00000c0c,
     {4,2}$08000c0c,{5,2}$0c000c0c,{6,2}$0c080c0c,{7,2}$0c0c0c0c,
     {0,3}$00000200,{1,3}$00000300,{2,3}$00000302,{3,3}$00000303,
     {4,3}$02000303,{5,3}$03000303,{6,3}$03020303,{7,3}$03030303);
{$WARN BOUNDS_ERROR ON}

procedure TLifeCel.DrawHorzLineLeft(x1,y1: integer; State: TLineDrawState; QCycle: boolean);
var
  Part, Mask: integer;
begin
  Part:= XLookup[x1]+YLookUp[y1];
  Mask:= HorzMaskLeftLookup[(x1 and 7) + ((y1 and 3) * 8)];
  case QCycle of
    true: case State of
      lds_On: TInt(q)[Part]:= Tint(q)[Part] or Mask;
      lds_Off: TInt(q)[Part]:= TInt(q)[Part] and not(Mask);
      lds_Xor: TInt(q)[Part]:= Tint(q)[Part] xor Mask;
    end; {Qcycle}
    false: case State of
      lds_On: TInt(p)[Part]:= Tint(p)[Part] or Mask;
      lds_Off: TInt(p)[Part]:= TInt(p)[Part] and not(Mask);
      lds_Xor: TInt(p)[Part]:= Tint(p)[Part] xor Mask;
    end; {PQcyle}
  end; {case}
  if Part > 3 then begin
    Dec(Part,4);
    Mask:= HorzMaskLeftLookup[(y1 and 3)*8+7];
    case QCycle of
      true: case State of
        lds_On: TInt(q)[Part]:= Tint(q)[Part] or Mask;
        lds_Off: TInt(q)[Part]:= TInt(q)[Part] and not(Mask);
        lds_Xor: TInt(q)[Part]:= Tint(q)[Part] xor Mask;
      end; {Qcycle}
      false: case State of
        lds_On: TInt(p)[Part]:= Tint(p)[Part] or Mask;
        lds_Off: TInt(p)[Part]:= TInt(p)[Part] and not(Mask);
        lds_Xor: TInt(p)[Part]:= Tint(p)[Part] xor Mask;
      end; {PQcyle}
    end; {case}
  end; {if}
end;

{$WARN BOUNDS_ERROR OFF}
const
  VertMaskUpLookup: array[0..31] of integer =
    ({0,0}$00008000,{1,0}$00004000,{2,0}$00000080,{3,0}$00000040,
     {4,0}$80000000,{5,0}$40000000,{6,0}$00800000,{7,0}$00400000,
     {0,1}$0000a000,{1,1}$00005000,{2,1}$000000a0,{3,1}$00000050,
     {4,1}$a0000000,{5,1}$50000000,{6,1}$00a00000,{7,1}$00500000,
     {0,2}$0000a800,{1,2}$00005400,{2,2}$000000a8,{3,2}$00000054,
     {4,2}$a8000000,{5,2}$54000000,{6,2}$00a80000,{7,2}$00540000,
     {0,3}$0000aa00,{1,3}$00005500,{2,3}$000000aa,{3,3}$00000055,
     {4,3}$aa000000,{5,3}$55000000,{6,3}$00aa0000,{7,3}$00550000);
{$WARN BOUNDS_ERROR ON}

procedure TLifeCel.DrawVertLineUp(x1,y1: integer; State: TLineDrawState; QCycle: boolean);
var
  Part, Mask: integer;
begin
  Part:= XLookup[x1]+YLookUp[y1];
  Mask:= VertMaskUpLookup[(x1 and 7) + ((y1 and 3) * 8)];
  case QCycle of
    true: case State of
      lds_On: TInt(q)[Part]:= Tint(q)[Part] or Mask;
      lds_Off: TInt(q)[Part]:= TInt(q)[Part] and not(Mask);
      lds_Xor: TInt(q)[Part]:= Tint(q)[Part] xor Mask;
    end; {Qcycle}
    false: case State of
      lds_On: TInt(p)[Part]:= Tint(p)[Part] or Mask;
      lds_Off: TInt(p)[Part]:= TInt(p)[Part] and not(Mask);
      lds_Xor: TInt(p)[Part]:= Tint(p)[Part] xor Mask;
    end; {PQcyle}
  end; {case}
  while ((Part and 3) > 0) do begin
    Dec(Part);
    Mask:= VertMaskUpLookup[(x1 and 7) + (3*8)];
    case QCycle of
      true: case State of
        lds_On: TInt(q)[Part]:= Tint(q)[Part] or Mask;
        lds_Off: TInt(q)[Part]:= TInt(q)[Part] and not(Mask);
        lds_Xor: TInt(q)[Part]:= Tint(q)[Part] xor Mask;
      end; {Qcycle}
      false: case State of
        lds_On: TInt(p)[Part]:= Tint(p)[Part] or Mask;
        lds_Off: TInt(p)[Part]:= TInt(p)[Part] and not(Mask);
        lds_Xor: TInt(p)[Part]:= Tint(p)[Part] xor Mask;
      end; {PQcyle}
    end; {case}
  end; {while}
end;

procedure TLifeCel.ExchangeTorusLineHorz(y1,y2: integer; c: TLifeCel; QCycle: boolean);
var
  RowA, RowB: TRow;
  PartA, MaskA: integer;
  {PartB,} MaskB: integer;
begin
  PartA:= XLookup[0]+YLookup[y1];
  MaskA:= HorzMaskRightLookup[(y1 and 3)*8];
  //PartB:= XLookup[0]+YLookup[y2];
  MaskB:= HorzMaskRightLookup[(y2 and 3)*8];
  case QCycle of
    true: begin
      RowA[0]:= TInt(q)[PartA] and MaskA;
      RowA[1]:= TInt(q)[PartA+4] and MaskA;
      RowB[0]:= TInt(c.q)[PartA] and MaskB;
      RowB[1]:= TInt(c.q)[PartA+4] and MaskB;
      //Now shift the A-row to fit the B-cell and visa versa
    end; {QCycle}
    false:begin
      RowA[0]:= TInt(p)[PartA] and MaskA;
      RowA[1]:= TInt(p)[PartA+4] and MaskA;
      RowB[0]:= TInt(c.p)[PartA] and MaskB;
      RowB[1]:= TInt(c.p)[PartA+4] and MaskB;
    end; {PCycle}
  end; {case}
end;

procedure TLifeCel.ExchangeTorusLineVert(x1,x2: integer; c: TLifeCel; QCycle: boolean);
begin
end;





function TLifeCel.TopRow(QCycle: boolean): integer;
var
  HLines: array[0..3] of integer;
  i: integer;
  Ready: boolean;
begin
  if Assigned(Self) then begin
    case QCycle of
			true:begin
				HLines[0]:= (q[0] or q[1] or q[8]  or q[9]);
				HLines[1]:= (q[2] or q[3] or q[$a] or q[$b]);
				HLines[2]:= (q[4] or q[5] or q[$c] or q[$d]);
				HLines[3]:= (q[6] or q[7] or q[$e] or q[$f]);
      end; {true}
      false:begin
				HLines[0]:= (p[0] or p[1] or p[8]  or p[9]);
				HLines[1]:= (p[2] or p[3] or p[$a] or p[$b]);
				HLines[2]:= (p[4] or p[5] or p[$c] or p[$d]);
				HLines[3]:= (p[6] or p[7] or p[$e] or p[$f]);
      end;{false}
    end; {case}
    if (HLines[0] or HLines[1] or HLines[2] or HLines[3]) =0 then Result:= 16
    else begin
			i:= 0;
			Ready:= false;
      Result:= 0;
			while (i <= 3) and not(Ready) do begin
				if HLines[i] = 0 then Inc(Result,4)
				else begin
					Ready:= true;
					if (HLines[i] and $fcfc) = 0 then Inc(Result,3)
					else if (HLines[i] and $f0f0) = 0 then Inc(Result,2)
					else if (Hlines[i] and $c0c0) = 0 then Inc(Result,1);
				end; {else}
				Inc(i);
			end; {while}
    end; {else}
  end {if}
  else Result:= 16;
end;

function TLifeCel.BottomRow(QCycle: boolean): integer;
var
  HLines: array[0..3] of integer;
  i: integer;
  Ready: boolean;

begin
  if Assigned(Self) then begin
    case QCycle of
			true:begin
				HLines[0]:= (q[0] or q[1] or q[8]  or q[9]);
				HLines[1]:= (q[2] or q[3] or q[$a] or q[$b]);
				HLines[2]:= (q[4] or q[5] or q[$c] or q[$d]);
				HLines[3]:= (q[6] or q[7] or q[$e] or q[$f]);
      end; {true:}
      false:begin
				HLines[0]:= (p[0] or p[1] or p[8]  or p[9]);
				HLines[1]:= (p[2] or p[3] or p[$a] or p[$b]);
				HLines[2]:= (p[4] or p[5] or p[$c] or p[$d]);
				HLines[3]:= (p[6] or p[7] or p[$e] or p[$f]);
      end; {false}
    end; {case}
    if (HLines[0] or HLines[1] or HLines[2] or HLines[3]) =0 then Result:= -1
    else begin
      Result:= 15;
      i:= 3;
			Ready:= false;
			while (i >= 0)  and not(Ready) do begin
				if HLines[i] = 0 then Dec(Result,4)
				else begin
					Ready:= true;
					if (HLines[i] and $3f3f) = 0 then Dec(Result,3)
					else if (HLines[i] and $0f0f) = 0 then Dec(Result,2)
					else if (Hlines[i] and $0303) = 0 then Dec(Result,1);
				end; {else}
				Dec(i);
      end; {while}
    end; {else}
  end {if}
  else Result:= -1;
end;


function TLifeCel.LeftCol(QCycle: boolean):integer;
var
  VLines: array[0..3] of integer;
  i: integer;
  Ready: boolean;
begin
  if Assigned(Self) then begin
    case QCycle of
      true: begin
	      VLines[0]:= (q[0] or q[2]  or q[4]  or q[6]);
	      VLines[1]:= (q[1] or q[3]  or q[5]  or q[7]);
	      VLines[2]:= (q[8] or q[$a] or q[$c] or q[$e]);
	      VLines[3]:= (q[9] or q[$b] or q[$d] or q[$f]);
      end; {true}
      false: begin
        VLines[0]:= (p[0] or p[2]  or p[4]  or p[6]);
        VLines[1]:= (p[1] or p[3]  or p[5]  or p[7]);
        VLines[2]:= (p[8] or p[$a] or p[$c] or p[$e]);
        VLines[3]:= (p[9] or p[$b] or p[$d] or p[$f]);
      end; {false}
    end; {case}
    if (VLines[0] or VLines[1] or VLines[2] or VLines[3]) =0 then Result:= 16
    else begin
      i:= 0;
			Ready:= false;
      Result:= 0;
			while (i <= 3) and not(Ready) do begin
				if VLines[i] = 0 then Inc(Result,4)
				else begin
					Ready:= true;
					if (VLines[i] and $ffaa) = 0 then Inc(Result,3)
					else if (VLines[i] and $ff00) = 0 then Inc(Result,2)
					else if (Vlines[i] and $aa00) = 0 then Inc(Result,1);
				end; {else}
				Inc(i);
			end; {while}
    end; {else}
  end {if}
  else Result:= 16;
end;


function TLifeCel.RightCol(QCycle: boolean): integer;
var
  VLines: array[0..3] of integer;
  i: integer;
  Ready: boolean;
begin
  if Assigned(Self) then begin
    case QCycle of
      true: begin
	      VLines[0]:= (q[0] or q[2]  or q[4]  or q[6]);
	      VLines[1]:= (q[1] or q[3]  or q[5]  or q[7]);
	      VLines[2]:= (q[8] or q[$a] or q[$c] or q[$e]);
	      VLines[3]:= (q[9] or q[$b] or q[$d] or q[$f]);
      end; {true}
      false: begin
        VLines[0]:= (p[0] or p[2]  or p[4]  or p[6]);
        VLines[1]:= (p[1] or p[3]  or p[5]  or p[7]);
        VLines[2]:= (p[8] or p[$a] or p[$c] or p[$e]);
        VLines[3]:= (p[9] or p[$b] or p[$d] or p[$f]);
      end; {false}
    end; {case}
    if (VLines[0] or VLines[1] or VLines[2] or VLines[3]) =0 then Result:= -1
    else begin
      i:= 3;
			Ready:= false;
      Result:= 15;
			while (i >= 0)  and not(Ready) do begin
				if VLines[i] = 0 then Dec(Result,4)
				else begin
					Ready:= true;
					if (VLines[i] and $55ff) = 0 then Dec(Result,3)
					else if (VLines[i] and $00ff) = 0 then Dec(Result,2)
					else if (Vlines[i] and $0055) = 0 then Dec(Result,1);
				end; {else}
				Dec(i);
			end; {while}
		end; {else}
  end {if}
  else Result:= -1;
end;

(*       f  e  7  6  1f 1e 17 16 | 8f 8e 87 86  9f 9e 97 96
         d  c  5  4  1d 1c 15 14 | 8d 8c 85 84  9d 9c 95 94
         b  a  3  2  1b 1a 13 12 | 8b 8a 83 82  9b 9a 93 92
         9  8  1  0  19 18 11 10 | 89 88 81 80  99 98 91 90
                                 |
        2f 2e 27 26 3f 3e 37 36  | af ae a7 a6  bf be b7 b6
        2d 2c 25 24 3d 3c 35 34  | ad ac a5 a4  bd bc b5 b4
        2b 2a 23 22 3b 3a 33 32  | ab aa a3 a2  bb ba b3 b2
        29 28 21 20 39 38 31 30  | a9 a8 a1 a0  b9 b8 b1 b0
       __________________________|__________________________
                                 |
        4f 4e 47 46  5f 5e 57 56 | cf ce c7 c6  df de d7 d6
        4d 4c 45 44  5d 5c 55 54 | cd cc c5 c4  dd dc d5 d4
        4b 4a 43 42  5b 5a 53 52 | cb ca c3 c2  db da d3 d2
        49 48 41 40  59 58 51 50 | c9 c8 c1 c0  d9 d8 d1 d0
                                 |
        6f 7e 77 76  7f 7e 77 76 | ef ee e7 e6  ff fe f7 f6
        6d 7c 75 74  7d 7c 75 74 | ed ec e5 e4  fd fc f5 f4
        6b 7a 73 72  7b 7a 73 72 | eb ea e3 e2  fb fa f3 f2
        69 78 71 70  79 78 71 70 | e9 e8 e1 e0  f9 f8 f1 f0 (**)

//0 is the top row, 15 is the bottom row.
//no testing for row validness is done.
function TLifeCel.GetAColumn(AColumn: integer; QCycle: boolean): TColumn;
const
  Mask = $aa00; {f-d-b-9---------}
var
  ColumnBlock: integer;
  ColumnMask: integer;
begin
  ColumnBlock:= AColumn shr 2; {div 4}
  if ColumnBlock > 2 then Inc(ColumnBlock,8);
  if QCycle then begin
    Result[0]:= q[ColumnBlock];
    Result[1]:= q[ColumnBlock+2];
    Result[2]:= q[ColumnBlock+4];
    Result[3]:= q[ColumnBlock+6];
  end {if}
  else begin
    Result[0]:= p[ColumnBlock];
    Result[1]:= p[ColumnBlock+2];
    Result[2]:= p[ColumnBlock+4];
    Result[3]:= p[ColumnBlock+6];
  end; {else}
  //Shift masks 0, 1, 8 or 9 positions.
  //This corresponds to the 1,2,3 and 4th column.
  ColumnMask:= Mask;
  case AColumn and $3 of
    1: ColumnMask:= ColumnMask shr 1;
    2: ColumnMask:= ColumnMask shr 8;
    3: ColumnMask:= ColumnMask shr 9;
  end; {case}
  Result[0]:= Result[0] and ColumnMask;
  Result[1]:= Result[1] and ColumnMask;
  Result[2]:= Result[2] and ColumnMask;
  Result[3]:= Result[3] and ColumnMask;
end;

function TLifeCel.GetARow(ARow: integer; QCycle: boolean): TRow;
const
  Mask = $c0c0c0c0; {fe------76------FE------76------}
var
  RowBlock: integer;
  RowMask: integer;
begin
  RowBlock:= ARow shr 2; {div 4}
  if QCycle then begin
    Result[0]:= TInt(q)[RowBlock];
    Result[1]:= TInt(q)[RowBlock+8];
  end
  else begin
    Result[0]:= TInt(p)[RowBlock];
    Result[1]:= TInt(p)[RowBlock+8];
  end;
  // Shift mask 0, 2, 4 or 6 positions
  //this corresponds to the 0th, 1st, 2nd and 3rd row.
  RowMask:= Mask shr ((ARow and $3) * 2);
  Result[0]:= Result[0] and RowMask;
  Result[1]:= Result[1] and RowMask;
end;

procedure TLifeCel.ClearRow(ARow: integer; QCycle: Boolean);
const
  Mask = $c0c0c0c0;
var
  RowBlock: integer;
  RowMask: integer;
begin
  RowBlock:= ARow shr 2; {div 4}
  RowMask:= Mask shr ((ARow and $3) * 2);
  RowMask:= not RowMask;
  if QCycle then begin
    TInt(q)[RowBlock]:= TInt(q)[RowBlock] and RowMask;
    TInt(q)[RowBlock+8]:= TInt(q)[RowBlock+8] and RowMask;
    qstate:= 0;                       //alive = waar
    if Assigned(N) then N.qstate:= N.qstate and $ff00ff00;
    if Assigned(W) then W.qstate:= W.qstate and $ffff0000;
    if Assigned(NW) then NW.qstate:= NW.qstate and $ffffff00;
  end
  else begin
    TInt(p)[RowBlock]:= TInt(p)[RowBlock] and RowMask;
    TInt(p)[RowBlock+8]:= TInt(p)[RowBlock+8] and RowMask;
    pstate:= 0;
    if Assigned(S) then S.pstate:= S.pstate and $00ff00ff;
    if Assigned(E) then E.pstate:= E.pstate and $0000ffff;
    if Assigned(SE) then SE.pstate:= SE.pstate and $00ffffff;
  end;
end;

procedure TLifeCel.ClearColumn(AColumn: integer; QCycle: boolean);
const
  Mask = $aa00; {f-d-b-9---------}
var
  ColumnBlock: integer;
  ColumnMask: integer;
begin
  ColumnBlock:= AColumn shr 2; {div 4}
  if ColumnBlock > 2 then Inc(ColumnBlock,8);
  ColumnMask:= Mask;
  case AColumn and $3 of
    1: ColumnMask:= ColumnMask shr 1;
    2: ColumnMask:= ColumnMask shr 8;
    3: ColumnMask:= ColumnMask shr 9;
  end; {case}
  ColumnMask:= not ColumnMask;
  if QCycle then begin
    q[ColumnBlock]:= q[ColumnBlock] and ColumnMask;
    q[ColumnBlock+2]:= q[ColumnBlock+2] and ColumnMask;
    q[ColumnBlock+4]:= q[ColumnBlock+4] and ColumnMask;
    q[ColumnBlock+6]:= q[ColumnBlock+6] and ColumnMask;
    qstate:= 0;                       //alive = waar
    if Assigned(N) then N.qstate:= N.qstate and $ff00ff00;
    if Assigned(W) then W.qstate:= W.qstate and $ffff0000;
    if Assigned(NW) then NW.qstate:= NW.qstate and $ffffff00;
  end {if}
  else begin
    p[ColumnBlock]:= p[ColumnBlock] and ColumnMask;
    p[ColumnBlock+2]:= p[ColumnBlock+2] and ColumnMask;
    p[ColumnBlock+4]:= p[ColumnBlock+4] and ColumnMask;
    p[ColumnBlock+6]:= p[ColumnBlock+6] and ColumnMask;
    pstate:= 0;
    if Assigned(S) then S.pstate:= S.pstate and $00ff00ff;
    if Assigned(E) then E.pstate:= E.pstate and $0000ffff;
    if Assigned(SE) then SE.pstate:= SE.pstate and $00ffffff;
  end; {else}
end;


procedure TLifeCel.Write(AStream: TStream; QCycle: boolean);
begin
  with AStream do begin
    Write(coor.x,SizeOf(coor.x));
    Write(coor.y,SizeOf(coor.y));
    if QCycle then begin
      Write(q,SizeOf(q));
    end {if for i}
    else begin
      Write(p,SizeOf(p));
    end;
  end; {with}
end;

procedure TLifeCel.Read(AStream: TStream; QCycle: boolean);
begin
  with AStream do begin
    Read(coor.x,SizeOf(coor.x));
    Read(coor.y,SizeOf(coor.y));
    if QCycle then begin
      Read(q,SizeOf(q));
    end {if}
    else begin
      Read(p,SizeOf(p));
    end; {else}
  end; {with}
end;


procedure SetBounds(AWindow: TControl; ARect: TRect);
begin
  DrawBound:= ARect;
  if (MyDDSurface.DirectDrawEnabled = DDFast) then with DrawBound do begin
    TopLeft:= AWindow.ClientToScreen(TopLeft);
    BottomRight:= AWindow.ClientToScreen(BottomRight);
  end; {with}
  StartPoint.x:= DrawBound.Left - ARect.Left;
  StartPoint.y:= DrawBound.Top - ARect.Top;
end;

procedure SetDisplayProps(XOrig, YOrig,ox,oy, NegZoom: integer;
                          DisplayQGen: Boolean);
begin
  XOrigDiv16:= XOrig div 16;
  YOrigDiv16:= YOrig div 16;
  RestOfXOrig:= (((XOrig mod 16)-integer(DisplayQGen)) div (1 shl NegZoom));
  RestOfYOrig:= (((YOrig mod 16)-integer(DisplayQGen)) div (1 shl NegZoom));
  CenterX:= ox;
  CenterY:= oy;
  DisplayQ:= DisplayQGen;
end;

procedure InitDDraw;
begin
  if MyDDSurface = nil then MyDDSurface:= TMyDDSurface.Create(nil);
end;

procedure SetCelSpace(ACelSpace: integer; GridOn: Boolean);
begin
  //InitDDraw;
  CelSpace:= ACelSpace;
  CelSpace2:= CelSpace * 2;
  CelSpace4:= CelSpace * 4;
  CelSpace8:= CelSpace * 8;
  CelSpace12:= CelSpace * 12;
  CelSpace16:= CelSpace * 16;
  if CelSpace < 4 then CelSize:= CelSpace
  //the size of the gridlines is hereby fixed at 1 pixel width (high)
  else CelSize:= CelSpace - integer(GridOn);
  MyDDSurface.InitDrawRoutines(ACelSpace, GridOn);
end;


procedure DisplayChange(BitsPerPixel,Width,Height: integer);
begin
  if Assigned(MyDDSurface) then begin
    MyDDSurface.DisplayChange(BitsPerPixel,Width,Height);
  end; {if}
end;


initialization //this is executed BEFORE WinMain.
  MyDDSurface:= nil;
  {$ifdef time}
  CumDisp:= 0;
  CumDiff:= 0;
  {$endif}
finalization  //one of the very last statements in the entire program.
  MyDDSurface.Free;
end.
